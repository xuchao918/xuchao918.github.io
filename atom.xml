<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>起风了</title>
  
  <subtitle>xuchao&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-14T14:47:31.943Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>XuChao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次挖矿处理</title>
    <link href="http://yoursite.com/2019/11/13/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8C%96%E7%9F%BF%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/11/13/记一次挖矿处理/</id>
    <published>2019-11-13T15:02:30.000Z</published>
    <updated>2019-11-14T14:47:31.943Z</updated>
    
    <content type="html"><![CDATA[<p>11月10日周日晚上21:58分收到阿里云监控告警邮件，提示云服务器被挖矿，顿时意识到事情严重，于是立马登陆到机器上处理。<br><img src="/images/1.png" alt="image"></p><h2 id="定位并清除挖矿程序"><a href="#定位并清除挖矿程序" class="headerlink" title="定位并清除挖矿程序"></a>定位并清除挖矿程序</h2><p>由于这是一个线上服务器，当前首要任务是找到并Kill掉挖矿病毒，恢复正常。<br>首先，使用top命令定位挖矿程序，发现是一个名称为base64的进程，妥妥的，CPU使用率飙到了715%。<br> <img src="/images/2.png" alt="image"></p><p>然后，查看该挖矿进程是如何运行的<br> <img src="/images/3.png" alt="image"></p><p>找到之后，我们要想办法尽快干掉它，恢复业务<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd /root/.tmp00</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line"><span class="keyword">bash </span> <span class="keyword">bash64 </span> <span class="keyword">bash.pid </span> cfg  cfgi  uuid</span><br></pre></td></tr></table></figure></p><p>收回程序的可执行权限，这里一定要先回收可执行权限才能kill掉进程，否则无效<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> chmod -x bash64 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chmod -x bash</span></span><br></pre></td></tr></table></figure></p><p>杀掉bash64进程<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pkill bash64</span></span><br></pre></td></tr></table></figure></p><p>接下来尝试删除病毒文件，发现删除后会自动生成，并自动运行。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rm -rf ./*</span></span><br></pre></td></tr></table></figure></p><p><img src="/images/4.png" alt="image"></p><p>因为一般病毒会使用chattr +i命令，于是使用chattr -i bash64，然后再 rm -f bash64，发现也无法删除。</p><p>于是只有重复上面步骤。<br>再次使用top命令查看，发现bash64挖矿进程消失，持续观察一段时间后进程没有再起来，总算先抑制住了，可以松口气了！</p><p><strong>遗留问题1：挖矿病毒暂时无法删除</strong></p><h2 id="定位并清除crontab定时任务"><a href="#定位并清除crontab定时任务" class="headerlink" title="定位并清除crontab定时任务"></a>定位并清除crontab定时任务</h2><p>OK，这里只是暂时压制住了这个邪恶的东西，继续排查其他问题。<br>接下来查看有无crontab定时任务<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># crontab -l</span></span><br><span class="line">*/1 * * * * <span class="builtin-name">export</span> <span class="attribute">DISPLAY</span>=:0 &amp;&amp; /root/.tmp00/bash &gt;/dev/<span class="literal">null</span> 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p><p>果然有，于是尝试使用crontab -e 删除掉crontab，纳尼，删掉后又自动创建了。</p><p>好吧，试试其他办法，于是<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /var/spool/cron</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rm -f root VM</span></span><br></pre></td></tr></table></figure></p><p><img src="/images/5.png" alt="image"></p><p>纳尼，root文件可以删除，VM删除后又自动生成，好吧，我尝试去修改它，发现修改后又会自动生成新的一行。<br><img src="/images/6.png" alt="image"></p><p>使用crontab -r也无法删除。</p><p>接下来，确认/etc/init.d目录下有没有挖矿程序，OK，没有。</p><p><strong>遗留问题2：该挖矿程序定时任务暂时无法删除</strong></p><h2 id="禁止挖矿程序连接网络"><a href="#禁止挖矿程序连接网络" class="headerlink" title="禁止挖矿程序连接网络"></a>禁止挖矿程序连接网络</h2><p>OK，那我们就追本溯源，看看/root/.tmp00/bash64这个程序，是黑猫还是白猫。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># more /root/.tmp00/bash</span></span><br><span class="line">******** /root/.tmp00/bash: Not <span class="keyword">a</span> <span class="keyword">text</span> <span class="built_in">file</span> ********</span><br></pre></td></tr></table></figure></p><p>尝试VIM打开，好吧，如所料这是一个编译后的文件(非bash脚本)无法直接查看。<br><img src="/images/7.png" alt="image"></p><p>回到上面，我们通过ps命令获悉该挖矿进程通过-c参数指定了配置文件，查看该配置文件的内容<br><img src="/images/8.png" alt="image"></p><p>好家伙，该文件内容经过base64编码处理，base64解码后配置内容如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"algo"</span>: <span class="string">"cryptonight"</span>,</span><br><span class="line"><span class="attr">"autosave"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"background"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"colors"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"retries"</span>: <span class="number">5</span>,</span><br><span class="line"><span class="attr">"retry-pause"</span>: <span class="number">5</span>,</span><br><span class="line"><span class="attr">"syslog"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"print-time"</span>: <span class="number">60</span>,</span><br><span class="line"><span class="attr">"av"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"safe"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"cpu-priority"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"cpu-affinity"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"donate-level"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"threads"</span>: <span class="number">8</span>,</span><br><span class="line"><span class="attr">"pools"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"url"</span>: <span class="string">"proxkekman.ru:8080"</span>,</span><br><span class="line"><span class="attr">"user"</span>: <span class="string">"0c82cc57-7dae-4d4b-a409-12afcc45136e"</span>,</span><br><span class="line"><span class="attr">"pass"</span>: <span class="string">"x"</span>,</span><br><span class="line"><span class="attr">"keepalive"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"nicehash"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"variant"</span>: <span class="string">"r"</span>,</span><br><span class="line"><span class="attr">"tls"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"tls-fingerprint"</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="attr">"api"</span>: &#123;</span><br><span class="line"><span class="attr">"port"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"access-token"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"worker-id"</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里，重点是这个url地址proxkekman.ru:8080。使用浏览器尝试访问页面无法打开，那使用telnet试试能否通。OK，能通。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">telnet</span> <span class="selector-tag">proxkekman</span><span class="selector-class">.ru</span><span class="selector-pseudo">:8080</span></span><br></pre></td></tr></table></figure></p><p>由于挖矿程序base和base64没有时间去解码，所以看不到程序代码。根据我的个人推测，挖矿病毒需要使用这个url地址去做些勾当，为了保险起见，于是使用iptables禁止访问这个url地址。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A <span class="keyword">INPUT</span> -s proxkekman.<span class="keyword">ru</span> -j <span class="keyword">DROP</span> </span><br><span class="line">iptables -A OUTPUT -<span class="keyword">d</span> proxkekman.<span class="keyword">ru</span> -j <span class="keyword">DROP</span></span><br></pre></td></tr></table></figure></p><p>其实，在最开始kill掉该进程前，我们可以使用netstat查看该进程使用的端口号。然后使用安全组规则或iptables drop该端口的连接。</p><p>流程走到这里时，有2个问题没有处理掉，即挖矿病毒文件和crontab定时任务没有清除掉。山雨欲来风满楼，刚好此时在网上找解决方法时，ssh连接因超时自动退出（做等保时加了配置），此时再次以root用户或其他用户登陆再执行sudo等命令时，发现该挖矿病毒在我最开始登陆之后的1分钟左右把root用户删掉了，重新创建了一个VM的超管账号，并破坏掉了sudo等命令。</p><p>综合评估最优选择，经过内部商议，决定回滚该云服务器的系统盘恢复系统（该实例运行的是边缘业务）。</p><h2 id="补充要点"><a href="#补充要点" class="headerlink" title="补充要点"></a>补充要点</h2><h3 id="如何快速定位异常用户"><a href="#如何快速定位异常用户" class="headerlink" title="如何快速定位异常用户"></a>如何快速定位异常用户</h3><p>检查系统用户，查看是否有异常的系统用户<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/passwd</span></span><br></pre></td></tr></table></figure></p><p>查看是否产生了新用户，UID和GID为0的用户<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">grep</span> “<span class="number">0</span>” <span class="regexp">/etc/</span>passwd</span><br></pre></td></tr></table></figure></p><p>查看passwd的修改时间，判断是否在不知的情况下添加用户<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls -l /etc/passwd</span></span><br></pre></td></tr></table></figure></p><p>查看是否存在特权用户<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr"># awk -F: ‘3</span>==<span class="number">0</span> &#123;pri<span class="symbol">nt3</span>==<span class="number">0</span> &#123;pri<span class="symbol">nt1</span>&#125;’ /etc/passwd</span><br></pre></td></tr></table></figure></p><p>查看是否存在空口令帐户<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr"># awk -F: ‘length(2</span>)==<span class="number">0</span> &#123;pri<span class="symbol">nt2</span>)==<span class="number">0</span> &#123;pri<span class="symbol">nt1</span>&#125;’ /etc/shadow</span><br></pre></td></tr></table></figure></p><p>打开 /root/.ssh/authorized_keys, 删除你不认识的账号。删除之前，先备份，以免误删。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp authorized_keys authorized_keys.<span class="keyword">back</span></span><br></pre></td></tr></table></figure></p><h3 id="清理定时任务"><a href="#清理定时任务" class="headerlink" title="清理定时任务"></a>清理定时任务</h3><p>(先清理定时任务，再删除挖矿病毒本体，防止再生)，包括但不限于<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta-keyword">/etc/</span>crontab</span><br><span class="line"><span class="meta-keyword">/var/</span>spool<span class="meta-keyword">/cron/</span>root</span><br><span class="line"><span class="meta-keyword">/var/</span>spool<span class="meta-keyword">/cron/</span>crontabs/root</span><br><span class="line"><span class="meta-keyword">/etc/</span>cron.d/system</span><br><span class="line"><span class="meta-keyword">/etc/</span>cron.d/root</span><br><span class="line"><span class="meta-keyword">/etc/</span>cron.hourly/oanacron</span><br><span class="line"><span class="meta-keyword">/etc/</span>cron.daily/oanacron</span><br><span class="line"><span class="meta-keyword">/etc/</span>cron.monthly/oanacron</span><br><span class="line"><span class="meta-keyword">/etc/</span>cron.monthly/oanacron3</span><br></pre></td></tr></table></figure></p><h3 id="删除相关动态链接库"><a href="#删除相关动态链接库" class="headerlink" title="删除相关动态链接库"></a>删除相关动态链接库</h3><p>包括但不限于<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/ld.so.preload</span><br><span class="line">/etc/libjdk.so</span><br><span class="line">/usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">md</span>.<span class="title">so</span></span></span><br><span class="line">/usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">screen</span>.<span class="title">so</span></span></span><br><span class="line">/usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">y</span>.<span class="title">so4</span></span></span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.服务器如非必须，禁止开放端口，按需开放即可；<br>2.重要服务的端口，如数据库等服务端口，应禁用默认端口，启用密码认证并禁止外网连接；<br>3.一定要有数据备份，包括业务数据备份（如数据库）和基础数据备份（如系统盘和数据盘）等。总之，有备份，睡觉也踏实；<br>4.及时修复系统漏洞，打安全补丁；<br>5.严格控制所有用户的操作权限，需特殊权限需特殊审批；</p><p>腾讯CTO张志东曾说：安全问题可以让腾讯一天倒闭。这是不是真的，我不知道。但笔者曾亲身经历过的公司因被专业黑客持续攻击，导致损失上百万，从而成为倒闭的主因之一。</p><p><strong>在此小记，以免忘了！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;11月10日周日晚上21:58分收到阿里云监控告警邮件，提示云服务器被挖矿，顿时意识到事情严重，于是立马登陆到机器上处理。&lt;br&gt;&lt;img src=&quot;/images/1.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;定位并清除挖矿程序&quot;&gt;&lt;a href=&quot;#定
      
    
    </summary>
    
    
      <category term="挖矿" scheme="http://yoursite.com/tags/%E6%8C%96%E7%9F%BF/"/>
    
  </entry>
  
  <entry>
    <title>Go+Vue.js开发Web应用</title>
    <link href="http://yoursite.com/2019/07/09/Go-Vue-js%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2019/07/09/Go-Vue-js开发Web应用/</id>
    <published>2019-07-09T13:00:50.000Z</published>
    <updated>2019-07-09T13:55:49.700Z</updated>
    
    <content type="html"><![CDATA[<p><strong>环境准备</strong></p><ol><li>安装go语言，配置go开发环境；</li><li>安装node.js以及npm环境；</li></ol><h2 id="使用Gin"><a href="#使用Gin" class="headerlink" title="使用Gin"></a>使用Gin</h2><p>为了快速搭建后端应用，采用了Gin作为Web框架。Gin是用Golang实现的一种Web框架，api非常友好，且拥有出色的路由性能和详细的错误提示，如果你想快速开发一个高性能的生产环境，Gin是一个不错的选择。</p><p><strong>开始一个项目</strong><br>下载和安装Gin：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/gin-gonic/gin</span><br></pre></td></tr></table></figure></p><p>目录结构<br><img src="/images/vue-01.png" alt="image"></p><p>在IDE开发工具中新建一个项目go-web，并建立一个main.go文件作为项目入口：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"go-web/router"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router.Init()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注： go中package main 必须包含一个main函数。<br>从上面的代码可以看到，我们引入了go-web下面的router包，并显式的调用了router的Init()函数， 那现在我们就在go-web项目下新建router目录，并在目录下建立router.go用于编写路由规则，代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> router</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">v1 := r.Group(<span class="string">"/v1"</span>)</span><br><span class="line">&#123;</span><br><span class="line">v1.GET(<span class="string">"/line"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 注意:在前后端分离过程中，需要注意跨域问题，因此需要设置请求头</span></span><br><span class="line">c.Writer.Header().Set(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>)</span><br><span class="line">legendData := []<span class="keyword">string</span>&#123;<span class="string">"周一"</span>, <span class="string">"周二"</span>, <span class="string">"周三"</span>, <span class="string">"周四"</span>, <span class="string">"周五"</span>, <span class="string">"周六"</span>, <span class="string">"周日"</span>&#125;</span><br><span class="line">xAxisData := []<span class="keyword">int</span>&#123;<span class="number">120</span>, <span class="number">240</span>, rand.Intn(<span class="number">500</span>), rand.Intn(<span class="number">500</span>), <span class="number">150</span>, <span class="number">230</span>, <span class="number">180</span>&#125;</span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">"legend_data"</span>: legendData,</span><br><span class="line"><span class="string">"xAxis_data"</span>:  xAxisData,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义默认路由</span></span><br><span class="line">r.NoRoute(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(http.StatusNotFound, gin.H&#123;</span><br><span class="line"><span class="string">"status"</span>: <span class="number">404</span>,</span><br><span class="line"><span class="string">"error"</span>:  <span class="string">"404, page not exists!"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run(<span class="string">":8000"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用curl测试效果：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -s  localhost:<span class="number">8000</span><span class="meta-keyword">/v1/</span>line</span><br><span class="line">&#123;<span class="string">"legend_data"</span>:[<span class="string">"周一"</span>,<span class="string">"周二"</span>,<span class="string">"周三"</span>,<span class="string">"周四"</span>,<span class="string">"周五"</span>,<span class="string">"周六"</span>,<span class="string">"周日"</span>],<span class="string">"xAxis_data"</span>:[<span class="number">120</span>,<span class="number">240</span>,<span class="number">81</span>,<span class="number">387</span>,<span class="number">150</span>,<span class="number">230</span>,<span class="number">180</span>]&#125;</span><br></pre></td></tr></table></figure></p><p>使用该接口返回一个json结构的数据<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -s  localhos<span class="variable">t:8000</span>/v1/<span class="built_in">line</span> | <span class="keyword">python</span> -<span class="keyword">m</span> json.tool</span><br></pre></td></tr></table></figure></p><h2 id="基于vue框架开发前端项目"><a href="#基于vue框架开发前端项目" class="headerlink" title="基于vue框架开发前端项目"></a>基于vue框架开发前端项目</h2><p>进入到go项目go-web的src目录下，使用vue-cli脚手架快速构建一个基于 webpack 模板的vue项目。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vue init webpack vue-test    //一路回车即可</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  <span class="built_in">cd</span> vue-test</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  cnpm install</span></span><br></pre></td></tr></table></figure></p><p>安装异步请求包<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cnpm install --save axios</span></span><br></pre></td></tr></table></figure></p><p>run的时候会根据配置进行webpack静态资源编译<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cnpm run dev</span></span><br></pre></td></tr></table></figure></p><p>当使用了cnpm run dev后，即成功运行起来一个前端服务，当使用浏览器访问<a href="http://127.0.0.1:8080时会看到类似下面的页面。" target="_blank" rel="noopener">http://127.0.0.1:8080时会看到类似下面的页面。</a><br><img src="/images/vue-02.png" alt="image"></p><p>vue渲染后端API数据。一个vue项目的源码部分由这么几个部分组成：<br><img src="/images/vue-03.png" alt="image"></p><ul><li>main.js: js主文件</li><li>App.vue: vue主文件</li><li>assets: 静态文件目录</li><li>components: 自定义组件</li><li>router: 路由目录</li></ul><h3 id="vue渲染后端数据"><a href="#vue渲染后端数据" class="headerlink" title="vue渲染后端数据"></a>vue渲染后端数据</h3><p>在vue-test项目的src目录下，编写一个ApiData.vue的组件<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"># cat components/ApiData.vue</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!--使用class来绑定css的样式文件--&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!--</span></span><span class="template-variable">&#123;&#123;&#125;&#125;</span><span class="xml"><span class="comment"> 输出对象属性和函数返回值--&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><span class="template-variable">&#123;&#123; msg &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>site : </span><span class="template-variable">&#123;&#123;site&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>url : </span><span class="template-variable">&#123;&#123;url&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><span class="template-variable">&#123;&#123;details()&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-for</span>=<span class="string">"data in ydata"</span> <span class="attr">:key</span>=<span class="string">"data"</span>&gt;</span></span><span class="template-variable">&#123;&#123;data&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-for</span>=<span class="string">"item in xdata"</span> <span class="attr">:key</span>=<span class="string">"item"</span>&gt;</span></span><span class="template-variable">&#123;&#123;item&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">import axios from 'axios'</span></span><br><span class="line"><span class="xml">export default &#123;</span></span><br><span class="line"><span class="xml">  name: 'apidata',</span></span><br><span class="line"><span class="xml">  // data用来定义返回数据的属性</span></span><br><span class="line"><span class="xml">  data () &#123;</span></span><br><span class="line"><span class="xml">    return &#123;</span></span><br><span class="line"><span class="xml">      msg: 'hello,xuchao918！',</span></span><br><span class="line"><span class="xml">      site: "xuchao918",</span></span><br><span class="line"><span class="xml">      url: "https://xuchao918.github.io",</span></span><br><span class="line"><span class="xml">      xdata: null,</span></span><br><span class="line"><span class="xml">      ydata: null,</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">  // 用于定义js的方法</span></span><br><span class="line"><span class="xml">  methods: &#123;</span></span><br><span class="line"><span class="xml">    details: function() &#123;</span></span><br><span class="line"><span class="xml">      return this.site</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">  mounted () &#123;</span></span><br><span class="line"><span class="xml">      // response返回一个json&#123;"data": "数据","status": "状态码","statusText":"状态文本","headers":&#123; "content-type": "application/json; charset=utf-8" &#125;,"config":"配置文件","method":"方法","url":"请求url","request":"请求体"&#125;</span></span><br><span class="line"><span class="xml">      axios.get('http://localhost:8000/v1/line').then(response =&gt; (this.xdata = response.data.legend_data,this.ydata = response.data.xAxis_data))</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--使用css的class选择器[多重样式的生效优先级]--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">.hello &#123;</span></span><br><span class="line"><span class="xml">  font-weight: normal;</span></span><br><span class="line"><span class="xml">  text-align:center;</span></span><br><span class="line"><span class="xml">  font-size:8pt;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">h3</span></span><br><span class="line"><span class="xml">&#123;</span></span><br><span class="line"><span class="xml">  text-align:center;</span></span><br><span class="line"><span class="xml">  font-size:20pt;</span></span><br><span class="line"><span class="xml">  color:red;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>在路由中增加我们的components<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># cat router/index.js</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld'</span></span><br><span class="line"><span class="comment">// 增加我们自定义的ApiData组件</span></span><br><span class="line"><span class="keyword">import</span> Hello <span class="keyword">from</span> <span class="string">'@/components/ApiData'</span></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'HelloWorld'</span>,</span><br><span class="line">      component: HelloWorld</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 在这里引用我们的组件</span></span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/test'</span>,</span><br><span class="line">      name: <span class="string">'Hello'</span>,</span><br><span class="line">      component: Hello</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在App.vue文件中定义我们的vue脚本， 增加如下内容<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Hello <span class="keyword">from</span> <span class="string">'./components/ApiData'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'test'</span>,</span></span><br><span class="line"><span class="undefined">  components: &#123;</span></span><br><span class="line"><span class="undefined">    Hello</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>最后，使用浏览器访问页面<br><a href="http://localhost:8080/test" target="_blank" rel="noopener">http://localhost:8080/test</a><br><img src="/images/vue-04.png" alt="image"></p><h3 id="Gin返回静态页面"><a href="#Gin返回静态页面" class="headerlink" title="Gin返回静态页面"></a>Gin返回静态页面</h3><p>我们在网站开发中肯定会涉及到静态资源的处理，下面是Gin返回静态页面，以及实现数据交互的简单例子。</p><p>在go项目下新建templates目录，目录下新建index.html，内容如下：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="template-variable">&#123;&#123; .title &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>新建一个group v2，并创建/index路由，返回静态html页面：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r.<span class="type">LoadHTMLGlob</span>(<span class="string">"templates/*"</span>)</span><br><span class="line">v2 := r.<span class="type">Group</span>(<span class="string">"/v2"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    v2.<span class="type">GET</span>(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(<span class="built_in">c</span> *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="built_in">c</span>.<span class="type">HTML</span>(http.<span class="type">StatusOK</span>, <span class="string">"index.html"</span>, gin.<span class="type">H</span>&#123;<span class="string">"title"</span>: <span class="string">"hello Gin."</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用LoadHTMLGlob定义模板文件路径，用c.HTML返回静态页面。访问:<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">'http://127.0.0.1:8000/v2/index'</span> -i</span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-<span class="built_in">Type</span>: <span class="built_in">text</span>/html; charset=utf-<span class="number">8</span></span><br><span class="line"><span class="built_in">Date</span>: Mon, <span class="number">18</span> Sep <span class="number">2017</span> <span class="number">08</span>:<span class="number">29</span>:<span class="number">13</span> GMT</span><br><span class="line">Content-Length: <span class="number">55</span></span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">    hello Gin.</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>Gin返回了静态文件index.html，并把title数据填充到了模板{{ .title }}<br>注：关于模板语言的使用，读者自行补充。当然静态资源我们也可以交由nginx等来处理，减少服务器压力。</p><p>此时，我们就可以看到vue成功将后端Golang的API数据进行渲染出来了。虽然只是简单渲染，但，基本上已经实现了后端API和前端vue项目的融合。接下来就需要根据需求继续改造了。</p><h2 id="问题1：浏览器URL地址自动加上-号"><a href="#问题1：浏览器URL地址自动加上-号" class="headerlink" title="问题1：浏览器URL地址自动加上#号"></a>问题1：浏览器URL地址自动加上#号</h2><p>浏览器访问VUE项目会在访问地址后面加上#，这个#其实是VUE的HASH模式所产生的，正确点来说是因为VUE使用了HASH模式。如果不想有#可以修改路由Router的mode为history即可。</p><p>例如在vue init webpack my-project创建项目完毕以后，在src-&gt;router-&gt;index.js里修改<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> default new Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>  <span class="comment">//把Router的mode修改为history模式,VueRouter默认的模式为HASH模式</span></span><br><span class="line">  ......</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>参考链接：<br><a href="http://www.10tiao.com/html/556/201711/2651933044/1.html" target="_blank" rel="noopener">http://www.10tiao.com/html/556/201711/2651933044/1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;环境准备&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装go语言，配置go开发环境；&lt;/li&gt;
&lt;li&gt;安装node.js以及npm环境；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用Gin&quot;&gt;&lt;a href=&quot;#使用Gin&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go操作MySql数据库的方式</title>
    <link href="http://yoursite.com/2019/06/13/Go%E6%93%8D%E4%BD%9CMySql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/06/13/Go操作MySql数据库的方式/</id>
    <published>2019-06-13T14:26:27.000Z</published>
    <updated>2019-06-17T15:23:03.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go操作Mysql数据库"><a href="#Go操作Mysql数据库" class="headerlink" title="Go操作Mysql数据库"></a>Go操作Mysql数据库</h2><p>使用Go操作MySQL等数据库，一般有两种方式：一是使用database/sql接口，直接在代码里硬编码sql语句；二是使用gorm，即对象关系映射的方式在代码里抽象的操作数据库。一般推荐使用第二种方式。</p><h3 id="使用database-sql接口"><a href="#使用database-sql接口" class="headerlink" title="使用database/sql接口"></a>使用database/sql接口</h3><p>Go没有内置的驱动支持任何数据库，但是Go定义了database/sql接口，用户可以基于驱动接口开发相应数据库的驱动。但缺点是，直接用 github.com/go-sql-driver/mysql 访问数据库都是直接写 sql，取出结果然后自己拼成对象，使用上面不是很方便，可读性也不好。</p><p>下载包<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/<span class="keyword">go</span>-sql-driver/mysql</span><br></pre></td></tr></table></figure></p><p>安装好 mysql 驱动之后，我们创建一张user表，并执行CRUD操作（增、删、改、查）。代码如下所示：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">"database/sql"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    _ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据库连接信息</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">USERNAME = <span class="string">"root"</span></span><br><span class="line">PASSWORD = <span class="string">"123456"</span></span><br><span class="line">NETWORK = <span class="string">"tcp"</span></span><br><span class="line">SERVER = <span class="string">"127.0.0.1"</span></span><br><span class="line">PORT = 3306</span><br><span class="line">DATABASE = <span class="string">"test"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//user表结构体定义</span></span><br><span class="line"><span class="keyword">type</span> User struct &#123;</span><br><span class="line">Id int `json:<span class="string">"id"</span> <span class="keyword">form</span>:<span class="string">"id"</span>`</span><br><span class="line">Username string `json:<span class="string">"username"</span> <span class="keyword">form</span>:<span class="string">"username"</span>`</span><br><span class="line">Password string `json:<span class="string">"password"</span> <span class="keyword">form</span>:<span class="string">"password"</span>`</span><br><span class="line">Status int   `json:<span class="string">"status"</span> <span class="keyword">form</span>:<span class="string">"status"</span>`      <span class="comment">// 0 正常状态， 1删除</span></span><br><span class="line">Createtime int64 `json:<span class="string">"createtime"</span> <span class="keyword">form</span>:<span class="string">"createtime"</span>`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">conn := fmt.Sprintf(<span class="string">"%s:%s@%s(%s:%d)/%s"</span>,USERNAME, PASSWORD, NETWORK, SERVER, PORT, DATABASE)</span><br><span class="line"><span class="keyword">DB</span>, <span class="keyword">err</span> := sql.<span class="keyword">Open</span>(<span class="string">"mysql"</span>, conn)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">fmt.Println(<span class="string">"connection to mysql failed:"</span>, <span class="keyword">err</span>)</span><br><span class="line"><span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">DB</span>.SetConnMaxLifetime(100*time.Second)  <span class="comment">//最大连接周期，超时的连接就close</span></span><br><span class="line">    <span class="keyword">DB</span>.SetMaxOpenConns(100)                <span class="comment">//设置最大连接数</span></span><br><span class="line">    CreateTable(<span class="keyword">DB</span>)</span><br><span class="line">    InsertData(<span class="keyword">DB</span>)</span><br><span class="line">    QueryOne(<span class="keyword">DB</span>)</span><br><span class="line">    QueryMulti(<span class="keyword">DB</span>)</span><br><span class="line">    UpdateData(<span class="keyword">DB</span>)</span><br><span class="line">    DeleteData(<span class="keyword">DB</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func CreateTable(<span class="keyword">DB</span> *sql.<span class="keyword">DB</span>) &#123;</span><br><span class="line">sql := `CREATE <span class="keyword">TABLE</span> <span class="keyword">IF</span> NOT EXISTS users(</span><br><span class="line">id INT(4) PRIMARY KEY AUTO_INCREMENT NOT NULL,</span><br><span class="line">username VARCHAR(64),</span><br><span class="line">password VARCHAR(64),</span><br><span class="line">status INT(4),</span><br><span class="line">createtime INT(10)</span><br><span class="line">); `</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, <span class="keyword">err</span> := <span class="keyword">DB</span>.Exec(sql); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">        fmt.Println(<span class="string">"create table failed:"</span>, <span class="keyword">err</span>)</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    &#125;</span><br><span class="line">fmt.Println(<span class="string">"create table successd"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">func InsertData(<span class="keyword">DB</span> *sql.<span class="keyword">DB</span>) &#123;</span><br><span class="line">    result,<span class="keyword">err</span> := <span class="keyword">DB</span>.Exec(<span class="string">"insert INTO users(username,password) values(?,?)"</span>,<span class="string">"test"</span>,<span class="string">"123456"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">err</span> != nil&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Insert data failed,err:%v"</span>, <span class="keyword">err</span>)</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    lastInsertID,<span class="keyword">err</span> := result.LastInsertId()    <span class="comment">//获取插入数据的自增ID</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Get insert id failed,err:%v"</span>, <span class="keyword">err</span>)</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Insert data id:"</span>, lastInsertID)</span><br><span class="line">   </span><br><span class="line">    rowsaffected,<span class="keyword">err</span> := result.RowsAffected()  <span class="comment">//通过RowsAffected获取受影响的行数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Get RowsAffected failed,err:%v"</span>,<span class="keyword">err</span>)</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Affected rows:"</span>, rowsaffected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询单行</span></span><br><span class="line">func QueryOne(<span class="keyword">DB</span> *sql.<span class="keyword">DB</span>) &#123;</span><br><span class="line">user := new(User)   <span class="comment">//用new()函数初始化一个结构体对象</span></span><br><span class="line">row := <span class="keyword">DB</span>.QueryRow(<span class="string">"select id,username,password from users where id=?"</span>, 1)</span><br><span class="line"><span class="comment">//row.scan中的字段必须是按照数据库存入字段的顺序，否则报错</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">err</span> := row.Scan(&amp;user.Id,&amp;user.Username,&amp;user.Password); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">fmt.Printf(<span class="string">"scan failed, err:%v\n"</span>, <span class="keyword">err</span>)</span><br><span class="line"><span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"Single row data:"</span>, *user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询多行</span></span><br><span class="line">func QueryMulti(<span class="keyword">DB</span> *sql.<span class="keyword">DB</span>) &#123;</span><br><span class="line">    user := new(User)</span><br><span class="line">    rows, <span class="keyword">err</span> := <span class="keyword">DB</span>.<span class="keyword">Query</span>(<span class="string">"select id,username,password from users where id = ?"</span>, 2)</span><br><span class="line">    </span><br><span class="line">    defer func() &#123;</span><br><span class="line">        <span class="keyword">if</span> rows != nil &#123;</span><br><span class="line">            rows.<span class="keyword">Close</span>()   <span class="comment">//关闭掉未scan的sql连接</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Query failed,err:%v\n"</span>, <span class="keyword">err</span>)</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="keyword">err</span> = rows.Scan(&amp;user.Id, &amp;user.Username, &amp;user.Password)  <span class="comment">//不scan会导致连接不释放</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"Scan failed,err:%v\n"</span>, <span class="keyword">err</span>)</span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"scan successd:"</span>, *user)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新数据</span></span><br><span class="line">func UpdateData(<span class="keyword">DB</span> *sql.<span class="keyword">DB</span>)&#123;</span><br><span class="line">    result,<span class="keyword">err</span> := <span class="keyword">DB</span>.Exec(<span class="string">"UPDATE users set password=? where id=?"</span>,<span class="string">"111111"</span>,1)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">err</span> != nil&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Insert failed,err:%v\n"</span>, <span class="keyword">err</span>)</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"update data successd:"</span>, result)</span><br><span class="line">    </span><br><span class="line">    rowsaffected,<span class="keyword">err</span> := result.RowsAffected()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Get RowsAffected failed,err:%v\n"</span>,<span class="keyword">err</span>)</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Affected rows:"</span>, rowsaffected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数据</span></span><br><span class="line">func DeleteData(<span class="keyword">DB</span> *sql.<span class="keyword">DB</span>)&#123;</span><br><span class="line">    result,<span class="keyword">err</span> := <span class="keyword">DB</span>.Exec(<span class="string">"delete from users where id=?"</span>,1)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">err</span> != nil&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Insert failed,err:%v\n"</span>,<span class="keyword">err</span>)</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"delete data successd:"</span>, result)</span><br><span class="line">    </span><br><span class="line">    rowsaffected,<span class="keyword">err</span> := result.RowsAffected()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Get RowsAffected failed,err:%v\n"</span>,<span class="keyword">err</span>)</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Affected rows:"</span>, rowsaffected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行程序，输出结果如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> successd</span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">data</span> <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">Affected <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">Single <span class="keyword">row</span> <span class="keyword">data</span>: &#123;<span class="number">1</span> <span class="keyword">test</span> <span class="number">123456</span> <span class="number">0</span> <span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">data</span> successd: &#123;<span class="number">0xc0000a0000</span> <span class="number">0xc000010280</span>&#125;</span><br><span class="line">Affected <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">data</span> successd: &#123;<span class="number">0xc0000a0000</span> <span class="number">0xc0000102b0</span>&#125;</span><br><span class="line">Affected <span class="keyword">rows</span>: <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>OK，到这里大家是不是觉得这种实现方式很繁琐，假如要修改某个sql语句需要在代码中修改，这样很麻烦，代码设计也比较糟糕。因此这种方式并不推荐使用。</p><h3 id="使用GORM"><a href="#使用GORM" class="headerlink" title="使用GORM"></a>使用GORM</h3><p>GORM（Object Relation Mapping），即Go语言中的对象关系映射，实际上就是对数据库的操作进行封装，对上层开发人员屏蔽数据操作的细节，开发人员看到的就是一个个对象，大大简化了开发工作，提高了生产效率。如GORM结合Gin等服务端框架使用可以开发出丰富的Rest API等。</p><p>首先，下载包<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/jinzhu/gorm</span><br><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/gin-gonic/gin</span><br></pre></td></tr></table></figure></p><p>使用Go的Gin框架和Gorm开发简单的CRUD API，代码如下<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"><span class="string">"github.com/jinzhu/gorm"</span></span><br><span class="line"><span class="number">_</span> <span class="string">"github.com/jinzhu/gorm/dialects/mysql"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="type">MysqlDB</span> *gorm.<span class="type">DB</span></span><br><span class="line"></span><br><span class="line">type <span class="type">User</span> <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line"><span class="type">Id</span>   int    `gorm:<span class="string">"size:11;primary_key;AUTO_INCREMENT;not null"</span> json:<span class="string">"id"</span>`</span><br><span class="line"><span class="type">Age</span>  int    `gorm:<span class="string">"size:11;DEFAULT NULL"</span> json:<span class="string">"age"</span>`</span><br><span class="line"><span class="type">Name</span> string `gorm:<span class="string">"size:255;DEFAULT NULL"</span> json:<span class="string">"name"</span>`</span><br><span class="line"><span class="comment">//gorm后添加约束，json后为对应mysql里的字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="type">MysqlDB</span>, err := gorm.<span class="type">Open</span>(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(127.0.0.1:3306)/test?charset=utf8"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.<span class="type">Println</span>(<span class="string">"failed to connect database:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    fmt.<span class="type">Println</span>(<span class="string">"connect database success"</span>)</span><br><span class="line">    <span class="type">MysqlDB</span>.<span class="type">SingularTable</span>(<span class="literal">true</span>)</span><br><span class="line">    <span class="type">MysqlDB</span>.<span class="type">AutoMigrate</span>(&amp;<span class="type">User</span>&#123;&#125;) <span class="comment">//自动建表</span></span><br><span class="line">    fmt.<span class="type">Println</span>(<span class="string">"create table success"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="type">MysqlDB</span>.<span class="type">Close</span>()</span><br><span class="line"></span><br><span class="line"><span class="type">Router</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Router</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.<span class="type">Default</span>()</span><br><span class="line"><span class="comment">//路径映射</span></span><br><span class="line">router.<span class="type">GET</span>(<span class="string">"/user"</span>, <span class="type">InitPage</span>)</span><br><span class="line">router.<span class="type">POST</span>(<span class="string">"/user/create"</span>, <span class="type">CreateUser</span>)</span><br><span class="line">router.<span class="type">GET</span>(<span class="string">"/user/list"</span>, <span class="type">ListUser</span>)</span><br><span class="line">router.<span class="type">PUT</span>(<span class="string">"/user/update"</span>, <span class="type">UpdateUser</span>)</span><br><span class="line">router.<span class="type">GET</span>(<span class="string">"/user/find"</span>, <span class="type">GetUser</span>)</span><br><span class="line">router.<span class="type">DELETE</span>(<span class="string">"/user/:id"</span>, <span class="type">DeleteUser</span>)</span><br><span class="line">router.<span class="type">Run</span>(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个路由都对应一个具体的函数操作,从而实现了对user的增,删,改,查操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitPage</span><span class="params">(<span class="built_in">c</span> *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="built_in">c</span>.<span class="type">JSON</span>(http.<span class="type">StatusOK</span>, gin.<span class="type">H</span>&#123;</span><br><span class="line"><span class="string">"message"</span>: <span class="string">"pong"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateUser</span><span class="params">(<span class="built_in">c</span> *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user <span class="type">User</span></span><br><span class="line"><span class="built_in">c</span>.<span class="type">BindJSON</span>(&amp;user)     <span class="comment">//使用bindJSON填充对象</span></span><br><span class="line"><span class="type">MysqlDB</span>.<span class="type">Create</span>(&amp;user) <span class="comment">//创建对象</span></span><br><span class="line"><span class="built_in">c</span>.<span class="type">JSON</span>(http.<span class="type">StatusOK</span>, &amp;user)    <span class="comment">//返回页面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateUser</span><span class="params">(<span class="built_in">c</span> *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user <span class="type">User</span></span><br><span class="line">id := <span class="built_in">c</span>.<span class="type">PostForm</span>(<span class="string">"id"</span>)                <span class="comment">//post方法取相应字段</span></span><br><span class="line">err := <span class="type">MysqlDB</span>.<span class="type">First</span>(&amp;user, id).<span class="type">Error</span> <span class="comment">//数据库查找主键=ID的第一行</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">c</span>.<span class="type">AbortWithStatus</span>(<span class="number">404</span>)</span><br><span class="line">fmt.<span class="type">Println</span>(err.<span class="type">Error</span>())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">c</span>.<span class="type">BindJSON</span>(&amp;user)</span><br><span class="line"><span class="type">MysqlDB</span>.<span class="type">Save</span>(&amp;user) <span class="comment">//提交更改</span></span><br><span class="line"><span class="built_in">c</span>.<span class="type">JSON</span>(http.<span class="type">StatusOK</span>, &amp;user)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListUser</span><span class="params">(<span class="built_in">c</span> *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user []<span class="type">User</span></span><br><span class="line">line := <span class="built_in">c</span>.<span class="type">Query</span>(<span class="string">"line"</span>)</span><br><span class="line"><span class="type">MysqlDB</span>.<span class="type">Limit</span>(line).<span class="type">Find</span>(&amp;user) <span class="comment">//限制查找前line行</span></span><br><span class="line"><span class="built_in">c</span>.<span class="type">JSON</span>(http.<span class="type">StatusOK</span>, &amp;user)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUser</span><span class="params">(<span class="built_in">c</span> *gin.Context)</span></span> &#123;</span><br><span class="line">id := <span class="built_in">c</span>.<span class="type">Query</span>(<span class="string">"id"</span>)</span><br><span class="line"><span class="keyword">var</span> user <span class="type">User</span></span><br><span class="line">err := <span class="type">MysqlDB</span>.<span class="type">First</span>(&amp;user, id).<span class="type">Error</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">c</span>.<span class="type">AbortWithStatus</span>(<span class="number">404</span>)</span><br><span class="line">fmt.<span class="type">Println</span>(err.<span class="type">Error</span>())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">c</span>.<span class="type">JSON</span>(http.<span class="type">StatusOK</span>, &amp;user)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteUser</span><span class="params">(<span class="built_in">c</span> *gin.Context)</span></span>  &#123;</span><br><span class="line">    id := <span class="built_in">c</span>.<span class="type">Param</span>(<span class="string">"id"</span>)</span><br><span class="line">    <span class="keyword">var</span> user <span class="type">User</span></span><br><span class="line">    <span class="type">MysqlDB</span>.<span class="type">Where</span>(<span class="string">"id = ?"</span>, id).<span class="type">Delete</span>(&amp;user)</span><br><span class="line">    <span class="built_in">c</span>.<span class="type">JSON</span>(http.<span class="type">StatusOK</span>, gin.<span class="type">H</span>&#123;</span><br><span class="line">        <span class="string">"data"</span>: <span class="string">"this has been deleted!"</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行程序，输出结果如下所示：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">connect database success</span><br><span class="line">create table success</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">[GIN-<span class="builtin-name">debug</span>] <span class="builtin-name">GET</span>    <span class="built_in">/user </span>                    --&gt; main.InitPage (3 handlers)</span><br><span class="line">[GIN-<span class="builtin-name">debug</span>] POST   /user/create              --&gt; main.CreateUser (3 handlers)</span><br><span class="line">[GIN-<span class="builtin-name">debug</span>] <span class="builtin-name">GET</span>    /user/list                --&gt; main.ListUser (3 handlers)</span><br><span class="line">[GIN-<span class="builtin-name">debug</span>] PUT    /user/update              --&gt; main.UpdateUser (3 handlers)</span><br><span class="line">[GIN-<span class="builtin-name">debug</span>] <span class="builtin-name">GET</span>    /user/<span class="builtin-name">find</span>                --&gt; main.GetUser (3 handlers)</span><br><span class="line">[GIN-<span class="builtin-name">debug</span>] DELETE /user/:id                 --&gt; main.DeleteUser (3 handlers)</span><br><span class="line">[GIN-<span class="builtin-name">debug</span>] Listening <span class="keyword">and</span> serving HTTP on :8080</span><br></pre></td></tr></table></figure></p><p>如果要对上述接口进行测试，可以使用postman等工具.经测试可以实现对user的增,删,改,查操作。</p><p>如下，使用GET方法请求/user接口。<br><img src="/images/gorm-01.png" alt="image"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过非常简短的代码,就可以实现功能强大的restful接口,go语言的优势也是非常明显的.关于gin和gorm还有更加深入的内容.掌握好这两个工具可以轻松的构建web应用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go操作Mysql数据库&quot;&gt;&lt;a href=&quot;#Go操作Mysql数据库&quot; class=&quot;headerlink&quot; title=&quot;Go操作Mysql数据库&quot;&gt;&lt;/a&gt;Go操作Mysql数据库&lt;/h2&gt;&lt;p&gt;使用Go操作MySQL等数据库，一般有两种方式：一是使用da
      
    
    </summary>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Spark入门介绍</title>
    <link href="http://yoursite.com/2019/06/01/Spark%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/06/01/Spark入门介绍/</id>
    <published>2019-06-01T15:29:44.000Z</published>
    <updated>2019-06-01T15:50:01.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spark介绍"><a href="#Spark介绍" class="headerlink" title="Spark介绍"></a>Spark介绍</h2><p>Apache Spark 是用Scala语言开发的专为大数据处理而设计的计算引擎，类似于Hadoop MapReduce框架，Spark拥有Hadoop MapReduce所具有的优点，即Job中间输出结果可以保存在内存中，从而不再需要读写HDFS，因此Spark能更好地适用于数据挖掘与机器学习等需要迭代的MapReduce的算法。</p><p>Spark组件介绍，下图蓝色部分。<br><img src="/images/spark-01.png" alt="image"></p><p>Spark有很多组件来解决使用Hadoop MapReduce时出现的问题。Spark有以下组件：</p><ul><li>Spark Core</li><li>Spark Streaming</li><li>Spark SQL</li><li>GraphX</li><li>MLlib (Machine Learning)</li></ul><h3 id="Spark-Core"><a href="#Spark-Core" class="headerlink" title="Spark Core"></a>Spark Core</h3><p>Spark Core是大规模并行和分布式数据处理的基础引擎。 核心是分布式执行引擎，Java，Scala和Python API为分布式ETL应用程序开发提供了一个平台。 此外，在核心上构建的其他库允许用于流式传输，SQL和机器学习的各种工作负载。 它负责：</p><ul><li>内存管理和故障恢复</li><li>在群集上调度，分发和监视作业</li><li>与存储系统交互</li></ul><h3 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h3><p>Spark Streaming是Spark的组件，用于处理实时流数据。支持实时数据流的高吞吐量和容错流处理。 基本流单元是DStream，它基本上是一系列用于处理实时数据的RDD（弹性分布式数据集）。</p><h3 id="Spark-SQL"><a href="#Spark-SQL" class="headerlink" title="Spark SQL"></a>Spark SQL</h3><p>Spark SQL是Spark中的一个新模块，它使用Spark编程API实现集成关系处理。 它支持通过SQL或Hive查询查询数据。 对于那些熟悉RDBMS的人来说，Spark SQL将很容易从之前的工具过渡到可以扩展传统关系数据处理的边界。</p><p>Spark SQL通过函数编程API集成关系处理。 此外，它为各种数据源提供支持，并且使用代码转换编织SQL查询，从而产生一个非常强大的工具。以下是Spark SQL的四个库。</p><ul><li>Data Source API</li><li>DataFrame API</li><li>Interpreter &amp; Optimizer</li><li>SQL Service</li></ul><h3 id="GraphX"><a href="#GraphX" class="headerlink" title="GraphX"></a>GraphX</h3><p>GraphX是用于图形和图形并行计算的Spark API。 因此，它使用弹性分布式属性图扩展了Spark RDD。</p><h3 id="MlLib-Machine-Learning"><a href="#MlLib-Machine-Learning" class="headerlink" title="MlLib (Machine Learning)"></a>MlLib (Machine Learning)</h3><p>MLlib代表机器学习库。 Spark MLlib用于在Apache Spark中执行机器学习。</p><h2 id="Spark架构分布"><a href="#Spark架构分布" class="headerlink" title="Spark架构分布"></a>Spark架构分布</h2><p>下面来看看spark各个节点的分布图，如下<br><img src="/images/spark-02.png" alt="image"></p><p>Spark采用的是Master-Slave模型，从上面可以看出分为四个部分，Client、Driver、ClusterManager、Worker。</p><ul><li>client：客户端进程，负责提交job到master</li><li>Driver：运行Application，主要是做一些job的初始化工作，包括job的解析，DAG的构建和划分并提交和监控task</li><li>Cluster Manager：在standalone模式中即为Master主节点，控制整个集群，监控worker，在YARN模式中为资源管理器ResourceManager</li><li>Worker：负责管理本节点的资源，定期向Master汇报心跳，接收Master的命令，启动Driver。Executor，即真正执行作业的地方，一个Executor可以执行一到多个Task</li></ul><h2 id="使用基于Hadoop的Spark"><a href="#使用基于Hadoop的Spark" class="headerlink" title="使用基于Hadoop的Spark"></a>使用基于Hadoop的Spark</h2><p>Spark与Hadoop兼容性的。 因此，这是一种非常强大的技术组合。Hadoop组件可以通过以下方式与Spark一起使用：</p><ul><li>HDFS：Spark可以在HDFS之上运行，以利用分布式存储。</li><li>MapReduce：Spark可以与MapReduce一起用于同一个Hadoop集群，也可以单独作为处理框架使用。</li><li>YARN：可以使Spark应用程序在YARN上运行。</li><li>批处理和实时处理：MapReduce和Spark一起使用，其中MapReduce用于批处理，Spark用于实时处理。</li></ul><h3 id="Spark各组件应用场景"><a href="#Spark各组件应用场景" class="headerlink" title="Spark各组件应用场景"></a>Spark各组件应用场景</h3><p>Spark的生态系统主要包含了Spark Core、Spark SQL、Spark Streaming、MLLib和GraphX 等组件。Spark生态系统组件的应用场景：<br><img src="/images/spark-03.png" alt="image"></p><h3 id="有了Hadoop，为什么使用spark"><a href="#有了Hadoop，为什么使用spark" class="headerlink" title="有了Hadoop，为什么使用spark"></a>有了Hadoop，为什么使用spark</h3><p>1、Spark Streaming是基于Spark实现的高吞吐与低延迟的分布式流处理系统。与Hadoop Storm相比，两者在功能上是一致的，都实现了数据流的实时处理；但Storm的延迟在豪秒级别，而Spark Streaming是在秒级别，所以在一些实时响应要求高的应用场景中，需要使用Storm。</p><p>2、由于Hadoop生态系统中的一些组件所实现的功能，目前是无法由Spark取代的，比如Storm、HDFS。现有的Hadoop组件开发的应用，完全转移到Spark上需要一定的成本，不同的计算框架统一运行在YARN中，可以带来如下好处：</p><ul><li>计算资源按需伸缩</li><li>不用负载应用混搭，集群利用率高</li><li>共享底层存储，避免数据跨集群迁移</li></ul><p>3、实际上，Spark可以看作是Hadoop MapReduce的一个替代品而不是Hadoop的替代品。</p><h2 id="Hadoop和Spark优缺点"><a href="#Hadoop和Spark优缺点" class="headerlink" title="Hadoop和Spark优缺点"></a>Hadoop和Spark优缺点</h2><ul><li>使用Hadoop进行迭代计算非常耗资源。MapReduce是把中间结果写入到HDFS中，带来了大量的数据复制、磁盘IO和序列化开销。</li><li>Spark将中间结果保存在内存中，之后的迭代计算都可以直接使用内存中的中间结果作运算，避免了从磁盘中频繁读取数据。</li><li>Hadoop Storm在实时延迟度上比Spark Streaming好很多，前者是纯实时（纯实时的流式处理框架，即来一条数据就处理一条数据），后者是准实时（对一个时间段内的数据收集起来再做处理）。而且，Storm的事务机制、健壮性 / 容错性等特性，都要比Spark Streaming更加优秀。</li></ul><h2 id="spark三种部署模式区别和介绍"><a href="#spark三种部署模式区别和介绍" class="headerlink" title="spark三种部署模式区别和介绍"></a>spark三种部署模式区别和介绍</h2><p>Spark支持的主要三种分布式部署方式分别是standalone、spark on mesos和 spark on YARN。</p><ul><li>standalone模式，即独立模式，自带完整的服务，可单独部署到一个集群中，无需依赖任何其他资源管理系统。它是Spark实现的资源调度框架，其主要的节点有Client节点、Master节点和Worker节点。</li><li>spark on yarn模式，yarn是统一的资源管理机制，在上面可以运行多套计算框架，如map reduce、storm等根据driver在集群中的位置不同，分为yarn client和yarn cluster。生产环境上一般使用yarn cluster模式。</li><li>spark on mesos模式，mesos是一个更强大的分布式资源管理框架，它允许多种不同的框架部署在其上，包括yarn。</li></ul><p>一般，Spark使用CDH安装部署，具体步骤，请参考：<a href="https://xuchao918.github.io/2019/05/31/Centos7%E5%AE%89%E8%A3%85%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0CDH-6-2/" title="Centos7安装大数据平台CDH 6.2" target="_blank" rel="noopener">Centos7安装大数据平台CDH 6.2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spark介绍&quot;&gt;&lt;a href=&quot;#Spark介绍&quot; class=&quot;headerlink&quot; title=&quot;Spark介绍&quot;&gt;&lt;/a&gt;Spark介绍&lt;/h2&gt;&lt;p&gt;Apache Spark 是用Scala语言开发的专为大数据处理而设计的计算引擎，类似于Hadoop
      
    
    </summary>
    
    
      <category term="Spark" scheme="http://yoursite.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Centos7安装大数据平台CDH 6.2</title>
    <link href="http://yoursite.com/2019/05/31/Centos7%E5%AE%89%E8%A3%85%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0CDH-6-2/"/>
    <id>http://yoursite.com/2019/05/31/Centos7安装大数据平台CDH-6-2/</id>
    <published>2019-05-31T13:33:18.000Z</published>
    <updated>2019-05-31T14:56:23.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CDH-和Cloudera-Manager介绍"><a href="#CDH-和Cloudera-Manager介绍" class="headerlink" title="CDH 和Cloudera Manager介绍"></a>CDH 和Cloudera Manager介绍</h2><h3 id="1-CDH介绍"><a href="#1-CDH介绍" class="headerlink" title="1.CDH介绍"></a>1.CDH介绍</h3><p>目前Hadoop比较流行的主要有2个版本，Apache和Cloudera版本。</p><ul><li>Apache Hadoop：社区人员比较多，更新频率比较快，但是稳定性比较差，安装配置繁琐，实际使用者少。</li><li>Cloudera Hadoop（CDH）：Cloudera公司的发行版本，基于Apache Hadoop的二次开发，优化了组件兼容和交互接口、简化安装配置、提供界面统一管理程序。</li></ul><p><strong>CDH 提供以下特性：</strong></p><ul><li>灵活性：存储任何类型的数据并使用各种不同的计算框架进行操作，包括批处理、交互式SQL、文本搜索、机器学习和统计计算。</li><li>集成：在一个完整的Hadoop平台上快速启动和运行，该平台与广泛的硬件和软件解决方案一起工作。</li><li>安全：处理和控制敏感数据。</li><li>可伸缩性：启用广泛的应用程序和规模，并扩展它们以满足您的需求。</li><li>高可用性：稳定地执行关键的业务任务。</li><li>兼容性：利用您现有的IT基础设施和投资。</li></ul><p>CDH 组件如下图：<br><img src="/images/cdh-01.jpg" alt="image"></p><h3 id="2-Cloudera-Manager-介绍"><a href="#2-Cloudera-Manager-介绍" class="headerlink" title="2.Cloudera Manager 介绍"></a>2.Cloudera Manager 介绍</h3><p>Cloudera Manager 是用于管理cdh集群的端到端应用程序，统一管理和安装。CDH除了可以通过cm安装也可以通过yum,tar,rpm安装。主要由如下几部分组成：</p><ul><li><p>服务端/Server：<br>Cloudera Manager 的核心。主要用于管理 web server 和应用逻辑。它用于安装软件，配置，开始和停止服务，以及管理服务运行的集群。</p></li><li><p>代理/agent：<br>安装在每台主机上。它负责启动和停止进程，部署配置，触发安装和监控主机。</p></li><li><p>数据库/Database：<br>存储配置和监控信息。通常可以在一个或多个数据库服务器上运行的多个逻辑数据库。例如，所述的 Cloudera 管理器服务和监视，后台程序使用不同的逻辑数据库。<br>Cloudera Repository：由cloudera manager 提供的软件分发库。</p></li><li><p>客户端/Clients：<br>提供了一个与 Server 交互的接口。</p></li></ul><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>1.节点准备（两个节点）</p><table><thead><tr><th>名称</th><th>IP</th><th>CM管理软件</th></tr></thead><tbody><tr><td>namenode01</td><td>172.16.12.11</td><td>Cloudera Manager Server&amp;Agent ，MariaDB</td></tr><tr><td>datanode01</td><td>172.16.12.12</td><td>Cloudera Manager Agent</td></tr></tbody></table><p>2.配置主机名和hosts解析(所有节点)<br>编辑/etc/hostname，修改主机名，并使用命令hostname使其立刻生效。编辑文件/etc/hosts，增加如下内容。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">172<span class="selector-class">.16</span><span class="selector-class">.12</span><span class="selector-class">.11</span>  <span class="selector-tag">namenode01</span></span><br><span class="line">172<span class="selector-class">.16</span><span class="selector-class">.12</span><span class="selector-class">.12</span>  <span class="selector-tag">datanode01</span></span><br></pre></td></tr></table></figure></p><p>3.关闭防火墙<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">systemctl</span> <span class="selector-tag">stop</span> <span class="selector-tag">firewalld</span><span class="selector-class">.service</span> &amp;&amp; <span class="selector-tag">systemctl</span> <span class="selector-tag">disable</span> <span class="selector-tag">firewalld</span><span class="selector-class">.service</span></span><br></pre></td></tr></table></figure></p><p>4.关闭SELinux<br><figure class="highlight purebasic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i 's<span class="symbol">#SELINUX</span>=enforcing<span class="symbol">#SELINUX</span>=disabled<span class="symbol">#g</span>' /etc/selinux/config</span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure></p><p>5.配置时间同步<br>chrony既可作时间服务器服务端，也可作客户端。chrony性能比ntp要好很多，且chrony配置简单、管理方便。</p><p>在服务器端的安装与配置<br>安装<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum -y install chrony</span></span><br></pre></td></tr></table></figure></p><p>编辑 /etc/chrony.conf 文件<br>按照你环境的要求，对下面的键进行添加，修改或者删除<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/chrony.conf </span></span><br><span class="line">server 0.centos.pool.ntp.org iburst</span><br><span class="line">server 1.centos.pool.ntp.org iburst</span><br><span class="line">server 2.centos.pool.ntp.org iburst</span><br><span class="line">server 3.centos.pool.ntp.org iburst</span><br></pre></td></tr></table></figure></p><p>使用NTP服务器的主机名或者IP地址替换 NTP_SERVER 。配置支持设置多个 server 值，默认使用上面四个</p><p>修改允许客户端访问<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Allow NTP client access from local network.</span><br><span class="line">allow <span class="number">172.16</span><span class="number">.12</span><span class="number">.0</span>/<span class="number">24</span></span><br></pre></td></tr></table></figure></p><p>重启服务<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> chronyd.service &amp;&amp; systemctl restart chronyd.service</span></span><br></pre></td></tr></table></figure></p><p>检查时间同步<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># chronyc sources</span><br><span class="line"><span class="number">210</span> Number of sources = <span class="number">4</span></span><br><span class="line">MS Name/IP address         Stratum Poll Reach LastRx Last sample               </span><br><span class="line">===============================================================================</span><br><span class="line">^? ntp1.ams1.nl.leaseweb.net     <span class="number">0</span>   <span class="number">8</span>     <span class="number">0</span>     -     +<span class="number">0</span>ns[   +<span class="number">0</span>ns] +/-    <span class="number">0</span>ns</span><br><span class="line">^? ntp.wdc1.us.leaseweb.net      <span class="number">0</span>   <span class="number">8</span>     <span class="number">0</span>     -     +<span class="number">0</span>ns[   +<span class="number">0</span>ns] +/-    <span class="number">0</span>ns</span><br><span class="line">^? <span class="number">119.79</span><span class="number">-161</span><span class="number">-57.</span>customer.l&gt;     <span class="number">0</span>   <span class="number">8</span>     <span class="number">0</span>     -     +<span class="number">0</span>ns[   +<span class="number">0</span>ns] +/-    <span class="number">0</span>ns</span><br><span class="line">^? ntp6.flashdance.cx            <span class="number">0</span>   <span class="number">8</span>     <span class="number">0</span>     -     +<span class="number">0</span>ns[   +<span class="number">0</span>ns] +/-    <span class="number">0</span>ns</span><br></pre></td></tr></table></figure></p><p>在其它客户端的安装与配置<br>同样在客户端安装<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum -y install chrony</span></span><br></pre></td></tr></table></figure></p><p>编辑 /etc/chrony.conf 文件<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/chrony.conf </span></span><br><span class="line">注释掉下面四个，加增一个内部时间同步服务器地址</span><br><span class="line"><span class="comment">#server 0.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 1.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 2.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 3.centos.pool.ntp.org iburst</span></span><br><span class="line">server 172.16.12.11 iburst</span><br></pre></td></tr></table></figure></p><p>重启服务<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> chronyd.service &amp;&amp; systemctl restart chronyd.service</span></span><br></pre></td></tr></table></figure></p><p>验证时间同步：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chronyc sources</span></span><br><span class="line">210 Number of sources = 1</span><br><span class="line">MS Name<span class="built_in">/IP address </span>        Stratum Poll Reach LastRx Last sample               </span><br><span class="line">===============================================================================</span><br><span class="line">^* namenode01                    3   6     7     0    +11us[-2339us] +/-   48ms</span><br></pre></td></tr></table></figure></p><p>6.禁用透明大页面压缩，CDH配置需要<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo never &gt; <span class="regexp">/sys/kernel</span><span class="regexp">/mm/transparent</span>_hugepage/defrag</span><br><span class="line">echo never &gt; <span class="regexp">/sys/kernel</span><span class="regexp">/mm/transparent</span>_hugepage/enabled</span><br></pre></td></tr></table></figure></p><p>并将上面的两条命令写入开机自启动/etc/rc.local。</p><p>7.优化交换分区<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"vm.swappiness = 10"</span> <span class="meta">&gt;&gt; </span>/etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></p><h2 id="安装-CM-和-CDH"><a href="#安装-CM-和-CDH" class="headerlink" title="安装 CM 和 CDH"></a>安装 CM 和 CDH</h2><p>1.配置 Cloudera Manager 仓库(所有节点)<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="regexp">//</span>archive.cloudera.com<span class="regexp">/cm6/</span><span class="number">6.2</span>.<span class="number">0</span><span class="regexp">/redhat7/yum</span><span class="regexp">/cloudera-manager.repo -P /</span>etc<span class="regexp">/yum.repos.d/</span></span><br><span class="line">rpm --import https:<span class="regexp">//</span>archive.cloudera.com<span class="regexp">/cm6/</span><span class="number">6.2</span>.<span class="number">0</span><span class="regexp">/redhat7/yum</span><span class="regexp">/RPM-GPG-KEY-cloudera</span></span><br></pre></td></tr></table></figure></p><p>使用在线安装会比较慢，建议先把需要的rpm下载下来，进行离线安装或者建私有仓库，涉及下面三个软件包：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">cloudera-manager-agent-6</span><span class="selector-class">.2</span><span class="selector-class">.0-968826</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span><span class="selector-class">.rpm</span>    </span><br><span class="line"><span class="selector-tag">cloudera-manager-server-6</span><span class="selector-class">.2</span><span class="selector-class">.0-968826</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span><span class="selector-class">.rpm</span></span><br><span class="line"><span class="selector-tag">cloudera-manager-daemons-6</span><span class="selector-class">.2</span><span class="selector-class">.0-968826</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span><span class="selector-class">.rpm</span></span><br></pre></td></tr></table></figure></p><p>2.配置 JDK (所有节点)<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>下载地址，https:<span class="regexp">//</span>repo.huaweicloud.com<span class="regexp">/java/</span>jdk<span class="regexp">/8u202-b08/</span></span><br><span class="line">rpm -ivh jdk-<span class="number">8</span>u202-linux-x64.rpm</span><br></pre></td></tr></table></figure></p><p>3.安装 CM Server 和 Agent<br>建议离线安装，把rpm包下载到服务器上面，传到其他节点一份，再本地安装，速度会快很多。<br>namenode01：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">yum</span> <span class="selector-tag">localinstall</span> <span class="selector-tag">cloudera-manager-daemons-6</span><span class="selector-class">.2</span><span class="selector-class">.0-968826</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span><span class="selector-class">.rpm</span> <span class="selector-tag">-y</span></span><br><span class="line"># <span class="selector-tag">yum</span> <span class="selector-tag">localinstall</span> <span class="selector-tag">cloudera-manager-agent-6</span><span class="selector-class">.2</span><span class="selector-class">.0-968826</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span><span class="selector-class">.rpm</span> <span class="selector-tag">-y</span></span><br><span class="line"># <span class="selector-tag">yum</span> <span class="selector-tag">localinstall</span> <span class="selector-tag">cloudera-manager-server-6</span><span class="selector-class">.2</span><span class="selector-class">.0-968826</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span><span class="selector-class">.rpm</span> <span class="selector-tag">-y</span></span><br></pre></td></tr></table></figure></p><p>datanode01：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">yum</span> <span class="selector-tag">localinstall</span> <span class="selector-tag">cloudera-manager-daemons-6</span><span class="selector-class">.2</span><span class="selector-class">.0-968826</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span><span class="selector-class">.rpm</span> <span class="selector-tag">-y</span></span><br><span class="line"># <span class="selector-tag">yum</span> <span class="selector-tag">localinstall</span> <span class="selector-tag">cloudera-manager-agent-6</span><span class="selector-class">.2</span><span class="selector-class">.0-968826</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span><span class="selector-class">.rpm</span> <span class="selector-tag">-y</span></span><br></pre></td></tr></table></figure></p><p>4.安装数据库<br>在namenode01节点，安装<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">yum</span> install <span class="keyword">mariadb* </span>-y</span><br></pre></td></tr></table></figure></p><p>可选步骤。根据官方推荐的配置，编辑文件/etc/my.cnf，修改成如下内容：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cp /etc/my.cnf&#123;,.bak&#125;</span></span><br><span class="line"><span class="comment"># vim  /etc/my.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">transaction-isolation = READ-COMMITTED</span><br><span class="line">symbolic-links = 0</span><br><span class="line">key_buffer = 16M</span><br><span class="line">key_buffer_size = 32M</span><br><span class="line">max_allowed_packet = 32M</span><br><span class="line">thread_stack = 256K</span><br><span class="line">thread_cache_size = 64</span><br><span class="line">query_cache_limit = 8M</span><br><span class="line">query_cache_size = 64M</span><br><span class="line">query_cache_type = 1</span><br><span class="line">max_connections = 550</span><br><span class="line">log_bin=/var/lib/mysql/mysql_binary_log</span><br><span class="line">server_id=1</span><br><span class="line">binlog_format = mixed</span><br><span class="line">read_buffer_size = 2M</span><br><span class="line">read_rnd_buffer_size = 16M</span><br><span class="line">sort_buffer_size = 8M</span><br><span class="line">join_buffer_size = 8M</span><br><span class="line">innodb_file_per_table = 1</span><br><span class="line">innodb_flush_log_at_trx_commit  = 2</span><br><span class="line">innodb_log_buffer_size = 64M</span><br><span class="line">innodb_buffer_pool_size = 4G</span><br><span class="line">innodb_thread_concurrency = 8</span><br><span class="line">innodb_flush_method = O_DIRECT</span><br><span class="line">innodb_log_file_size = 512M</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error=/var/log/mariadb/mariadb.log</span><br><span class="line">pid-file=/var/run/mariadb/mariadb.pid</span><br><span class="line">!includedir /etc/my.cnf.d</span><br></pre></td></tr></table></figure></p><p>启动服务<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="builtin-name">enable</span> mariadb &amp;&amp; systemctl restart mariadb</span><br></pre></td></tr></table></figure></p><p>初始化数据库，按照相关提示操作即可。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>bin<span class="regexp">/mysql_secure_installation</span></span><br></pre></td></tr></table></figure></p><p>5.安装 MySQL JDBC 驱动(所有节点)<br>用于各节点连接数据库。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.46.tar.gz</span></span><br><span class="line">tar xf mysql-connector-java-<span class="number">5.1</span>.<span class="number">46</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line"></span><br><span class="line">mkdir -<span class="selector-tag">p</span> /usr/share/java/</span><br><span class="line">cd mysql-connector-java-<span class="number">5.1</span>.<span class="number">46</span></span><br><span class="line">cp mysql-connector-java-<span class="number">5.1</span>.<span class="number">46</span>-bin<span class="selector-class">.jar</span> /usr/share/java/mysql-connector-java.jar</span><br></pre></td></tr></table></figure></p><p>6.为 Cloudera 各软件创建数据库<br><img src="/images/cdh-02.png" alt="image"></p><p>将如下内容，写入到cdh.sql文件中。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> scm <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> scm.* <span class="keyword">TO</span> <span class="string">'scm'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'wzlinux'</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> amon <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> amon.* <span class="keyword">TO</span> <span class="string">'amon'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'wzlinux'</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> rman <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> rman.* <span class="keyword">TO</span> <span class="string">'rman'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'wzlinux'</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> hue <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> hue.* <span class="keyword">TO</span> <span class="string">'hue'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'wzlinux'</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> metastore <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> metastore.* <span class="keyword">TO</span> <span class="string">'hive'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'wzlinux'</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> sentry <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> sentry.* <span class="keyword">TO</span> <span class="string">'sentry'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'wzlinux'</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">nav</span> <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> nav.* <span class="keyword">TO</span> <span class="string">'nav'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'wzlinux'</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> navms <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> navms.* <span class="keyword">TO</span> <span class="string">'navms'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'wzlinux'</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> oozie <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> oozie.* <span class="keyword">TO</span> <span class="string">'oozie'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'wzlinux'</span>;</span><br></pre></td></tr></table></figure></p><p>执行sql文件。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p<span class="tag">&lt;<span class="name">ROOT_PASSWORD</span>&gt;</span> <span class="tag">&lt; <span class="attr">.</span>/<span class="attr">cdh.sql</span></span></span><br></pre></td></tr></table></figure></p><p>7.设置 Cloudera Manager 数据库<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># /opt/cloudera/cm/schema/scm_prepare_database.sh mysql scm scm</span></span><br><span class="line"><span class="comment">//接着，输入scm数据库密码</span></span><br></pre></td></tr></table></figure></p><p>8.安装 CDH<br>CM安装成功之后，接下来我们就可以通过CM安装CDH的方式构建企业大数据平台。所以首先需要把CDH的parcels包下载到CM主服务器上。同样的，我们为了加速我们的安装，我们可以把需要下载的软件包提前下载下来，也可以创建CDH私有仓库。</p><p>下载CDH的软件包 parcels(namenode01)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /opt/cloudera/parcel-repo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> wget https://archive.cloudera.com/cdh6/6.2.0/parcels/CDH-6.2.0-1.cdh6.2.0.p0.967373-el7.parcel</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> wget https://archive.cloudera.com/cdh6/6.2.0/parcels/manifest.json</span></span><br></pre></td></tr></table></figure></p><p>生成一个sha文件。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sha1sum CDH<span class="number">-6.2</span><span class="number">.0</span><span class="number">-1.</span>cdh6<span class="number">.2</span><span class="number">.0</span>.p0<span class="number">.967373</span>-el7.parcel | awk '&#123; print $<span class="number">1</span> &#125;' &gt; CDH<span class="number">-6.2</span><span class="number">.0</span><span class="number">-1.</span>cdh6<span class="number">.2</span><span class="number">.0</span>.p0<span class="number">.967373</span>-el7.parcel.sha</span><br></pre></td></tr></table></figure></p><p>修改属主属组<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R cloudera-<span class="string">scm:</span>cloudera-scm <span class="regexp">/opt/</span>cloudera<span class="regexp">/parcel-repo/</span>*</span><br></pre></td></tr></table></figure></p><p>9.启动 Cloudera Manager Server<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl start cloudera-scm-server</span></span><br></pre></td></tr></table></figure></p><p>如果启动中有什么问题，可以查看日志。<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/<span class="built_in">log</span>/cloudera-scm-<span class="built_in">server</span>/cloudera-scm-<span class="built_in">server</span>.<span class="built_in">log</span></span><br></pre></td></tr></table></figure></p><h2 id="初始化-Cloudera-Manager"><a href="#初始化-Cloudera-Manager" class="headerlink" title="初始化 Cloudera Manager"></a>初始化 Cloudera Manager</h2><p>稍等下，浏览器打开<a href="http://172.16.12.11:7180，用户名和密码默认都是admin。" target="_blank" rel="noopener">http://172.16.12.11:7180，用户名和密码默认都是admin。</a><br><img src="/images/cdh-03.png" alt="image"></p><p>然后按需，继续下一步操作即可。</p><h2 id="CDH集群安装"><a href="#CDH集群安装" class="headerlink" title="CDH集群安装"></a>CDH集群安装</h2><p>指定要添加的节点。<br><img src="/images/cdh-04.png" alt="image"></p><p>选择存储库，之前我们已经在 CM Server 节点配置好了。<br><img src="/images/cdh-05.png" alt="image"></p><p>不勾选“安装 Oracle Java SE 开发工具包 (JDK)”，选择我们自己安装的 JDK。</p><p>提供 SSH 登录凭据。</p><p>安装 agents，因为之前我们已经安装了，所以这里速度会很快。</p><p>安装选定的Parcel，之前我们已经下载好，并配置好放在的 CM Server 节点的/opt/cloudera/parcel-repo。</p><p>检查主机正确性。</p><h2 id="集群设置"><a href="#集群设置" class="headerlink" title="集群设置"></a>集群设置</h2><p>选择要安装的服务，可以根据自己的需求进行软件安装。<br><img src="/images/cdh-06.png" alt="image"></p><p>自定义角色分配。<br><img src="/images/cdh-07.png" alt="image"></p><p>数据库设置。<br><img src="/images/cdh-08.png" alt="image"></p><p>审核更改，如果有特定目录的设定或者参数的设定，可以在这里进行更正。</p><p>然后按需，继续下一步操作，一般默认即可。</p><h2 id="管理集群"><a href="#管理集群" class="headerlink" title="管理集群"></a>管理集群</h2><p>首页Dashboard。<br><img src="/images/cdh-09.png" alt="image"></p><h2 id="卸载Cloudera-Manager"><a href="#卸载Cloudera-Manager" class="headerlink" title="卸载Cloudera Manager"></a>卸载Cloudera Manager</h2><p>如果因为其他原因，需要卸载Cloudera Manager，在各节点执行如下步骤即可。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop cloudera-scm-server</span><br><span class="line">systemctl stop cloudera-scm-agent</span><br><span class="line">yum -y remove <span class="string">'cloudera-manager-*'</span></span><br><span class="line"></span><br><span class="line">yum clean all</span><br><span class="line">umount cm_processes</span><br><span class="line">umount <span class="regexp">/var/</span>run<span class="regexp">/cloudera-scm-agent/</span>process</span><br><span class="line"></span><br><span class="line">rm -Rf <span class="regexp">/usr/</span>share<span class="regexp">/cmf /</span>var<span class="regexp">/lib/</span>cloudera* <span class="regexp">/var/</span>cache<span class="regexp">/yum/</span>cloudera* <span class="regexp">/var/</span>log<span class="regexp">/cloudera* /</span>var<span class="regexp">/run/</span>cloudera*</span><br><span class="line">rm -rf <span class="regexp">/tmp/</span>.scmpreparenode.lock</span><br><span class="line">rm -Rf <span class="regexp">/var/</span>lib<span class="regexp">/flume-ng /</span>var<span class="regexp">/lib/</span>hadoop* <span class="regexp">/var/</span>lib<span class="regexp">/hue /</span>var<span class="regexp">/lib/</span>navigator <span class="regexp">/var/</span>lib<span class="regexp">/oozie /</span>var<span class="regexp">/lib/</span>solr <span class="regexp">/var/</span>lib<span class="regexp">/sqoop* /</span>var<span class="regexp">/lib/</span>zookeeper</span><br><span class="line">rm -Rf datadrivepath<span class="regexp">/dfs datadrivepath/</span>mapred datadrivepath/yarn</span><br><span class="line"></span><br><span class="line">rm -rf <span class="regexp">/var/</span>lib<span class="regexp">/hadoop-* /</span>var<span class="regexp">/lib/</span>impala <span class="regexp">/var/</span>lib<span class="regexp">/solr /</span>var<span class="regexp">/lib/</span>zookeeper <span class="regexp">/var/</span>lib<span class="regexp">/hue /</span>var<span class="regexp">/lib/</span>oozie  <span class="regexp">/var/</span>lib<span class="regexp">/pgsql  /</span>var<span class="regexp">/lib/</span>sqoop2  <span class="regexp">/data/</span>dfs<span class="regexp">/  /</span>data<span class="regexp">/impala/</span> <span class="regexp">/data/</span>yarn<span class="regexp">/  /</span>dfs<span class="regexp">/ /</span>impala<span class="regexp">/ /</span>yarn<span class="regexp">/  /</span>var<span class="regexp">/run/</span>hadoop-*<span class="regexp">/ /</span>var<span class="regexp">/run/</span>hdfs-*<span class="regexp">/ /</span>usr<span class="regexp">/bin/</span>hadoop* <span class="regexp">/usr/</span>bin<span class="regexp">/zookeeper* /</span>usr<span class="regexp">/bin/</span>hbase* <span class="regexp">/usr/</span>bin<span class="regexp">/hive* /</span>usr<span class="regexp">/bin/</span>hdfs <span class="regexp">/usr/</span>bin<span class="regexp">/mapred /</span>usr<span class="regexp">/bin/</span>yarn <span class="regexp">/usr/</span>bin<span class="regexp">/sqoop* /</span>usr<span class="regexp">/bin/</span>oozie <span class="regexp">/etc/</span>hadoop* <span class="regexp">/etc/</span>zookeeper* <span class="regexp">/etc/</span>hive* <span class="regexp">/etc/</span>hue <span class="regexp">/etc/</span>impala <span class="regexp">/etc/</span>sqoop* <span class="regexp">/etc/</span>oozie <span class="regexp">/etc/</span>hbase* <span class="regexp">/etc/</span>hcatalog</span><br><span class="line"></span><br><span class="line">systemctl stop mariadb</span><br><span class="line">yum -y remove mariadb-*</span><br><span class="line">rm -rf <span class="regexp">/var/</span>lib/mysql</span><br><span class="line">rm -rf <span class="regexp">/var/</span>log/mysqld.log</span><br><span class="line">rm -rf <span class="regexp">/usr/</span>lib64/mysql</span><br><span class="line">rm -rf <span class="regexp">/usr/</span>share/mysql</span><br><span class="line">rm -rf <span class="regexp">/opt/</span>cloudera</span><br></pre></td></tr></table></figure></p><h2 id="配置CDH高可用HA"><a href="#配置CDH高可用HA" class="headerlink" title="配置CDH高可用HA"></a>配置CDH高可用HA</h2><p>典型的 HDFS HA 架构，通常由多个 Name Node 组成：一个处于 Active状态，其他处于 Standby 状态。Active NameNode 对外提供服务，比如处理来自客户端的请求，Standby NameNode 则不对外提供服务，仅同步 Active NameNode 的状态，以便能够在它失败时快速进行切换。</p><p>在使用大数据集群的时候容灾是一件很重要的事情，CM可以非常方便的进行HA配置，如HDFS、YARN、Sqoop等HA配置。这些HA的前提条件或保障如下：</p><ul><li>NameNode/JournalNode: 至少3个(奇数个)，主节点和备节点(硬件配置相同)，节点上的Mariadb数据库使用Galera Cluster双活HA方案；</li><li>Zookeeper: 至少3个(奇数个)，组建ZK集群；</li><li>DataNode：多节点；</li><li>其他，如服务器网卡bond，物理网络容灾等；</li></ul><p>最后，CDH高可用集群搭建完以后，就可以进行一些参数调优、各项测试了。</p><p>安装参考文档：<a href="https://www.cloudera.com/documentation/enterprise/6/latest/topics/installation.html" target="_blank" rel="noopener">https://www.cloudera.com/documentation/enterprise/6/latest/topics/installation.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CDH-和Cloudera-Manager介绍&quot;&gt;&lt;a href=&quot;#CDH-和Cloudera-Manager介绍&quot; class=&quot;headerlink&quot; title=&quot;CDH 和Cloudera Manager介绍&quot;&gt;&lt;/a&gt;CDH 和Cloudera Man
      
    
    </summary>
    
    
      <category term="Spark" scheme="http://yoursite.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Go并发-使用协程、通道和select</title>
    <link href="http://yoursite.com/2019/05/17/Go%E5%B9%B6%E5%8F%91-%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E3%80%81%E9%80%9A%E9%81%93%E5%92%8Cselect/"/>
    <id>http://yoursite.com/2019/05/17/Go并发-使用协程、通道和select/</id>
    <published>2019-05-17T11:20:02.000Z</published>
    <updated>2019-05-18T11:50:33.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通道和阻塞"><a href="#通道和阻塞" class="headerlink" title="通道和阻塞"></a>通道和阻塞</h2><p>通道（channel）和协程（goroutine）是实现Go并发程序的两种机制。其中，通道又分为无缓冲通道和有缓冲通道两种，在编写实际的并发程序时，基本都使用异步模式的有缓冲通道。通道又可细分为支持读和写的双向通道，只读的通道，只写的通道三种。</p><h3 id="通道阻塞场景"><a href="#通道阻塞场景" class="headerlink" title="通道阻塞场景"></a>通道阻塞场景</h3><p>无论是有缓存通道、还是无缓冲通道都存在阻塞的情况。阻塞场景共4个，有缓存和无缓冲各2个。</p><p>无缓冲通道的特点是，发送的数据需要被读取后发送才会完成（同步），它阻塞场景是：</p><ul><li>通道中无数据，但执行读通道。</li><li>通道中无数据，向通道写数据，但无协程读取。</li></ul><p>有缓存通道的特点是，有缓存时可以向通道中写入数据后直接返回（异步），它阻塞场景是：</p><ul><li>通道缓存无数据，但执行读通道(接收数据)。</li><li>通道缓存已经占满，向通道写数据(发送数据)，但无协程读。</li></ul><h2 id="使用协程、通道和select"><a href="#使用协程、通道和select" class="headerlink" title="使用协程、通道和select"></a>使用协程、通道和select</h2><p>Go的select关键字可以让我们操作多个通道，将协程（goroutine），通道（channel）和select结合起来构成了Go的一个强大特性。</p><p>首先，我们来看一个简短代码，如下所示<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)         <span class="comment">//定义两个有缓冲通道，容量为1</span></span><br><span class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">1</span>)   <span class="comment">//每隔1秒发送数据</span></span><br><span class="line">        c1 &lt;- <span class="string">"name: xuchao"</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">2</span>)    <span class="comment">//每隔2秒发送数据</span></span><br><span class="line">        c2 &lt;- <span class="string">"age: 25"</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++ &#123;                <span class="comment">//使用select来等待这两个通道的值，然后输出</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> msg1 := &lt;- c1:</span><br><span class="line">            fmt.Println(msg1)</span><br><span class="line">        <span class="keyword">case</span> msg2 := &lt;- c2:</span><br><span class="line">            fmt.Println(msg2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># go run channel.go </span></span><br><span class="line"><span class="symbol">name:</span> xuchao</span><br><span class="line"><span class="symbol">age:</span> <span class="number">25</span></span><br></pre></td></tr></table></figure></p><p>如我们所期望的，程序输出了正确的值。对于select语句而言，它不断地检测通道是否有值过来，一旦发现有值过来，立刻获取输出。</p><h2 id="使用Select-超时实现无阻塞读写"><a href="#使用Select-超时实现无阻塞读写" class="headerlink" title="使用Select+超时实现无阻塞读写"></a>使用Select+超时实现无阻塞读写</h2><p>select是执行选择操作的一个结构，它里面有一组case语句，它会执行其中无阻塞的那一个，如果都阻塞了，那就等待其中一个不阻塞，进而继续执行，它有一个default语句，该语句是永远不会阻塞的，我们可以借助它实现无阻塞的操作。</p><p>但使用default实现的无阻塞通道阻塞有一个缺陷：当通道不可读或写的时候，会即可返回。实际场景更多的需求是，我们希望尝试读一会数据，或者尝试写一会数据，如果实在没法读写再返回，程序继续做其它的事情。</p><p>使用定时器替代default可以解决这个问题，给通道增加读写数据的容忍时间，如果5s内无法读写，就即刻返回。示例代码修改一下会是这样：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>) <span class="comment">//定义两个有缓冲通道，容量分别为1</span></span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                     <span class="comment">//定义一个协程</span></span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>) <span class="comment">//隔1秒发送数据</span></span><br><span class="line">c1 &lt;- <span class="string">"name: xuchao"</span>        <span class="comment">//向c1通道发送数据</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">6</span>) <span class="comment">//隔6秒发送数据</span></span><br><span class="line">c2 &lt;- <span class="string">"age: 25"</span>             <span class="comment">//向c2通道发送数据</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;                  <span class="comment">//使用select来获取这两个通道的值，然后输出</span></span><br><span class="line">tm := time.NewTimer(time.Second * <span class="number">5</span>) <span class="comment">//给通道创建容忍时间，如果5s内无法读写，就即刻返回</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg1 := &lt;-c1:          <span class="comment">//接收c1通道数据（消费数据）</span></span><br><span class="line">fmt.Println(msg1)</span><br><span class="line"><span class="keyword">case</span> msg2 := &lt;-c2:          <span class="comment">//接收c2通道数据（消费数据）</span></span><br><span class="line">fmt.Println(msg2)</span><br><span class="line"><span class="keyword">case</span> &lt;-tm.C:</span><br><span class="line">fmt.Println(<span class="string">"send data timeout!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果就会变成超时返回：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go run channel2.go </span></span><br><span class="line"><span class="built_in">name</span>: xuchao</span><br><span class="line">send data <span class="keyword">timeout</span>!</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>为什么Go语言对通道要限制长度而不提供无限长度的通道？</strong><br>我们知道通道（channel）是在两个 goroutine间通信的桥梁。当数据提供方供给速度大于消费方数据处理速度时，如果通道不限制长度，那么内存将不断膨胀直到应用崩溃。因此，限制通道的长度有利于约束数据提供方的供给速度，才能正常地处理数据。</p><p><strong>常用的select场景</strong></p><ul><li>无阻塞的读、写通道。即使通道是带缓存的，也是存在阻塞的情况，使用select可以完美的解决阻塞读写。</li><li>给某个请求/处理/操作，设置超时时间，一旦超时时间内无法完成，则停止处理。</li><li>select本色：多通道处理。</li></ul><p><strong>解决阻塞的2种办法</strong></p><ul><li>使用select的default语句，在channel不可读写时，即可返回</li><li>使用select+定时器，在超时时间内，channel不可读写，则返回（推荐方式）</li></ul><p>记住，在for循环里不要使用select + time.After的组合，易造成内存泄漏，应当使用NewTimer来做定时器。当使用golang过程中，遇到性能和内存gc问题，都可以使用golang tool pprof来排查分析问题。</p><p>希望这篇文章对你开发Go并发程序有所启发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;通道和阻塞&quot;&gt;&lt;a href=&quot;#通道和阻塞&quot; class=&quot;headerlink&quot; title=&quot;通道和阻塞&quot;&gt;&lt;/a&gt;通道和阻塞&lt;/h2&gt;&lt;p&gt;通道（channel）和协程（goroutine）是实现Go并发程序的两种机制。其中，通道又分为无缓冲通道和有缓冲通
      
    
    </summary>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言中什么时候使用指针</title>
    <link href="http://yoursite.com/2019/05/10/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2019/05/10/Go语言中什么时候使用指针/</id>
    <published>2019-05-10T12:59:08.000Z</published>
    <updated>2019-05-14T14:16:39.332Z</updated>
    
    <content type="html"><![CDATA[<p><strong>说明：</strong>理解本文的前提是你对Go语言已有一定的基础了解。</p><p><strong>什么是指针：</strong>即一个指针变量指向一个值的内存地址。</p><p><strong>使用值类型和指针类型的区别</strong><br>首先，我们来看一个计算面积的代码，如下所示。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Rect struct &#123;                               <span class="comment">//定义一个结构体</span></span><br><span class="line">    <span class="built_in">width</span>  float64</span><br><span class="line">    length float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="built_in">rect</span> Rect) area() float64 &#123;               <span class="comment">//定义一个方法，按值传递</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">rect</span>.<span class="built_in">width</span> * <span class="built_in">rect</span>.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="built_in">rect</span> *Rect) area1() float64 &#123;            <span class="comment">//定义一个方法，按指针传递</span></span><br><span class="line">    <span class="built_in">rect</span>.<span class="built_in">width</span> *= <span class="number">2</span></span><br><span class="line">    <span class="built_in">rect</span>.length *= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rect</span>.<span class="built_in">width</span> * <span class="built_in">rect</span>.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var <span class="built_in">rect</span> = <span class="keyword">new</span>(Rect)     <span class="comment">//使用new函数创建一个结构体指针rect，也就是说rect的类型是*Rect</span></span><br><span class="line">    <span class="built_in">rect</span>.<span class="built_in">width</span> = <span class="number">100</span></span><br><span class="line">    <span class="built_in">rect</span>.length = <span class="number">200</span></span><br><span class="line">    fmt.Println(<span class="string">"Width:"</span>, <span class="built_in">rect</span>.<span class="built_in">width</span>, <span class="string">"Length:"</span>, <span class="built_in">rect</span>.length,<span class="string">"Area:"</span>, <span class="built_in">rect</span>.area())  <span class="comment">//通过结构体指针类型的变量调用area()方法</span></span><br><span class="line">    fmt.Println(<span class="string">"Width:"</span>, <span class="built_in">rect</span>.<span class="built_in">width</span>, <span class="string">"Length:"</span>, <span class="built_in">rect</span>.length,<span class="string">"Area:"</span>, <span class="built_in">rect</span>.area1())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Go语言中，默认是按值传递。当一个变量当作参数传递的时候，会创建一个变量的副本，然后传递给函数或者方法，你可以看到这个副本的地址和变量的地址是不一样的。当变量当做指针被传递的时候，一个新的指针被创建，它指向变量同样的内存地址，所以你可以将这个指针看成原始变量指针的副本。</p><p><strong>故此</strong><br>1.是否使用结构体指针，取决于是否要在函数内部改变传递进来的参数的值。如果你的struct足够大，使用指针可以加快效率。如果不使用指针，在函数内部则无法修改struct中的值。<br>2.结构体赋值默认是按值传递，你要改变原来的那个值，要使用指针（即如果你要修改对象本身，那就要传指针，否则修改的是副本）。</p><p>再来比较下使用指针修改原始变量的值。代码示例<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import(</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">func main()&#123; </span><br><span class="line">    <span class="selector-tag">i</span> := <span class="number">1</span>      <span class="comment">// i的类型是int型,值为1</span></span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">p</span> *int     <span class="comment">// p 的类型是int型的指针</span></span><br><span class="line">    p=&amp;<span class="selector-tag">i</span>         <span class="comment">// p 的值为i的内存地址</span></span><br><span class="line">    fmt.Printf(<span class="string">"i=%d;p=%d;*p=%d\n"</span>,<span class="selector-tag">i</span>,<span class="selector-tag">p</span>,*p)</span><br><span class="line"> </span><br><span class="line">    *p=<span class="number">2</span>    <span class="comment">// *p 的值为i变量地址的指针 ，这行代码也就等价于 i := 2，使用指针修改变量本身</span></span><br><span class="line">    fmt.Printf(<span class="string">"i=%d;p=%d;*p=%d\n"</span>,<span class="selector-tag">i</span>,<span class="selector-tag">p</span>,*p)</span><br><span class="line"> </span><br><span class="line">    <span class="selector-tag">i</span> := <span class="number">3</span>     <span class="comment">// 验证想法</span></span><br><span class="line">    fmt.Printf(<span class="string">"i=%d;p=%d;*p=%d\n"</span>,<span class="selector-tag">i</span>,<span class="selector-tag">p</span>,*p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上输出结果为：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;p=<span class="number">824633802904</span>;*p=<span class="number">1</span></span><br><span class="line">i=<span class="number">2</span>;p=<span class="number">824633802904</span>;*p=<span class="number">2</span></span><br><span class="line">i=<span class="number">3</span>;p=<span class="number">824633802904</span>;*p=<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p><strong>向函数传递指针参数</strong><br>Go 语言允许向函数传递指针，只需要在函数定义的参数上设置为指针类型即可。以下实例演示了如何向函数传递指针，并在函数调用后修改函数内的值，：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="keyword">int</span>= <span class="number">200</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">"交换前 a 的值 : %d\n"</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">"交换前 b 的值 : %d\n"</span>, b )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用函数用于交换值</span></span><br><span class="line"><span class="comment">   * &amp;a 指向 a 变量的地址</span></span><br><span class="line"><span class="comment">   * &amp;b 指向 b 变量的地址</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   swap(&amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">"交换后 a 的值 : %d\n"</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">"交换后 b 的值 : %d\n"</span>, b )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="keyword">int</span>, y *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="keyword">int</span></span><br><span class="line">   temp = *x    <span class="comment">/* 保存 x 地址的值 */</span></span><br><span class="line">   *x = *y      <span class="comment">/* 将 y 赋值给 x */</span></span><br><span class="line">   *y = temp    <span class="comment">/* 将 temp 赋值给 y */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">交换前 <span class="selector-tag">a</span> 的值 : <span class="number">100</span></span><br><span class="line">交换前 <span class="selector-tag">b</span> 的值 : <span class="number">200</span></span><br><span class="line">交换后 <span class="selector-tag">a</span> 的值 : <span class="number">200</span></span><br><span class="line">交换后 <span class="selector-tag">b</span> 的值 : <span class="number">100</span></span><br></pre></td></tr></table></figure></p><p><strong>go什么情况下使用指针</strong></p><ul><li>推荐在方法上使用指针（前提是这个类型不是 map、slice 等引用类型）</li><li>当结构体较大的时候使用指针会更高效，可以避免内存拷贝，“结构较大” 到底多大才算大可能需要自己或团队衡量，如超过 5 个字段或者根据结构体内存占用来计算</li><li>如果要修改结构体内部的数据或状态必须使用指针</li><li>如果方法的receiver是map、slice 、channel等引用类型不要使用指针</li><li>小数据类型如 bool、int 等没必要使用指针传递</li><li>如果该函数会修改receiver或变量等，使用指针</li></ul><p>推荐资料：<br><a href="https://blog.biezhi.me/2018/10/values-or-pointers-in-golang.html" target="_blank" rel="noopener">https://blog.biezhi.me/2018/10/values-or-pointers-in-golang.html</a><br><a href="https://blog.csdn.net/huwh_/article/details/77879970" target="_blank" rel="noopener">https://blog.csdn.net/huwh_/article/details/77879970</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;理解本文的前提是你对Go语言已有一定的基础了解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是指针：&lt;/strong&gt;即一个指针变量指向一个值的内存地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用值类型和指针类型的区别&lt;/strong&gt;&lt;br&gt;首先
      
    
    </summary>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>使用go发送邮件</title>
    <link href="http://yoursite.com/2019/05/04/%E4%BD%BF%E7%94%A8go%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/05/04/使用go发送邮件/</id>
    <published>2019-05-04T07:13:54.000Z</published>
    <updated>2019-05-04T07:27:37.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gomail介绍"><a href="#Gomail介绍" class="headerlink" title="Gomail介绍"></a>Gomail介绍</h2><p>Gomail 是一个简单、高效的发送电子邮件包，它经过良好的测试和记录。 Gomail 只能使用 SMTP 服务器发送电子邮件，但是 API 比较灵活的，很容易实现其他方法使用本地 Postfix、API 等发送电子邮件。 </p><p>项目地址: <a href="https://github.com/go-gomail/gomail" target="_blank" rel="noopener">https://github.com/go-gomail/gomail</a><br>文档：<a href="https://godoc.org/gopkg.in/gomail.v2" target="_blank" rel="noopener">https://godoc.org/gopkg.in/gomail.v2</a><br>示例：<a href="https://godoc.org/gopkg.in/gomail.v2#example-package" target="_blank" rel="noopener">https://godoc.org/gopkg.in/gomail.v2#example-package</a></p><p><strong>Gomail 支持：</strong></p><ul><li>附件</li><li>嵌入图像</li><li>HTML 和文本模板</li><li>特殊字符的自动编码</li><li>SSL 和 TLS</li><li>使用相同的 SMTP 连接发送多封电子邮件</li></ul><h2 id="使用gomail"><a href="#使用gomail" class="headerlink" title="使用gomail"></a>使用gomail</h2><p>下载gomail<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">go</span> <span class="built_in">get</span> gopkg.<span class="keyword">in</span>/gomail.v2</span><br></pre></td></tr></table></figure></p><p>代码示例<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"gopkg.in/gomail.v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := gomail.NewMessage()</span><br><span class="line">m.SetHeader(<span class="string">"From"</span>, <span class="string">"xiaoxu@126.com"</span>)                     <span class="comment">//发件人</span></span><br><span class="line">m.SetHeader(<span class="string">"To"</span>, <span class="string">"xiaoxu@163.com"</span>)           <span class="comment">//收件人</span></span><br><span class="line">m.SetAddressHeader(<span class="string">"Cc"</span>, <span class="string">"test@126.com"</span>, <span class="string">"test"</span>)     <span class="comment">//抄送人</span></span><br><span class="line">m.SetHeader(<span class="string">"Subject"</span>, <span class="string">"Hello!"</span>)                     <span class="comment">//邮件标题</span></span><br><span class="line">m.SetBody(<span class="string">"text/html"</span>, <span class="string">"使用Go测试发送邮件!"</span>)     <span class="comment">//邮件内容</span></span><br><span class="line">m.Attach(<span class="string">"E:\\IMGP0814.JPG"</span>)       <span class="comment">//邮件附件</span></span><br><span class="line"></span><br><span class="line">d := gomail.NewDialer(<span class="string">"smtp.126.com"</span>, <span class="number">465</span>, <span class="string">"xiaoxu@126.com"</span>, <span class="string">"1234567"</span>)  </span><br><span class="line">         <span class="comment">//邮件发送服务器信息,使用授权码而非密码</span></span><br><span class="line"><span class="keyword">if</span> err := d.DialAndSend(m); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Gomail介绍&quot;&gt;&lt;a href=&quot;#Gomail介绍&quot; class=&quot;headerlink&quot; title=&quot;Gomail介绍&quot;&gt;&lt;/a&gt;Gomail介绍&lt;/h2&gt;&lt;p&gt;Gomail 是一个简单、高效的发送电子邮件包，它经过良好的测试和记录。 Gomail 只能
      
    
    </summary>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>使用go读取配置文件</title>
    <link href="http://yoursite.com/2019/04/29/%E4%BD%BF%E7%94%A8go%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/04/29/使用go读取配置文件/</id>
    <published>2019-04-29T14:47:37.000Z</published>
    <updated>2019-05-04T07:37:44.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置工具的选择"><a href="#配置工具的选择" class="headerlink" title="配置工具的选择"></a>配置工具的选择</h2><p>通常，在一个或多个项目中会有多种格式的配置文件，比如PHP的php.ini文件、Nginx的server.conf文件，那么使用Golang怎么去读取这些不同格式的配置文件呢？</p><p>比如常见的有 JSON文件、INI文件、YAML文件和TOML文件等等。其中这些文件，对应的Golang处理库如下：</p><ul><li>encoding/json – 标准库中的包，可以处理JSON配置文件，缺点是不能加注释</li><li>gcfg&amp;goconfig – 处理INI配置文件</li><li>toml – 处理TOML配置文件</li><li>viper – 处理JSON, TOML, YAML, HCL以及Java properties配置文件</li></ul><p>通常情况下，推荐使用viper库来读取配置文件，虽然它不支持ini格式的配置文件，但我们可以使用goconfig 或gcfg.v1库读取ini 格式配置文件。</p><p><strong>viper 支持以下功能：</strong></p><ul><li>支持Yaml、Json、 TOML、HCL 等格式的配置文件</li><li>可以从文件、 io.Reader 、环境变量、cli命令行读取配置</li><li>支持自动转换的类型解析</li><li>可以远程从Key/Value中读取配置，需要导入 viper/remote 包</li><li>监听配置文件。以往我们修改配置文件后需要重启服务生效，而Viper使用watch函数可以让配置自动生效。</li></ul><h2 id="安装viper"><a href="#安装viper" class="headerlink" title="安装viper"></a>安装viper</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/spf13/viper</span><br><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/fsnotify/fsnotify</span><br></pre></td></tr></table></figure><h3 id="使用viper读取JSON配置文件"><a href="#使用viper读取JSON配置文件" class="headerlink" title="使用viper读取JSON配置文件"></a>使用viper读取JSON配置文件</h3><p>假设现在有一份 json 格式的配置文件 config.json<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"date"</span>: <span class="string">"2019-04-30"</span>,</span><br><span class="line">  <span class="attr">"mysql"</span>: &#123;</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"127.0.0.1:3306"</span>,</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"root"</span>,</span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">"123456"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>读取json配置文件<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/spf13/viper"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">viper.SetConfigName(<span class="string">"config"</span>)     <span class="comment">//设置配置文件的名字</span></span><br><span class="line">viper.AddConfigPath(<span class="string">"."</span>)           <span class="comment">//添加配置文件所在的路径</span></span><br><span class="line">viper.SetConfigType(<span class="string">"json"</span>)       <span class="comment">//设置配置文件类型，可选</span></span><br><span class="line">err := viper.ReadInConfig()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"config file error: %s\n"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">urlValue := viper.Get(<span class="string">"mysql.url"</span>)</span><br><span class="line">fmt.Println(<span class="string">"mysql url:"</span>, urlValue)</span><br><span class="line">        fmt.Printf(<span class="string">"mysql url: %s\n mysql username: %s\n mysql password: %s"</span>, viper.Get(<span class="string">"mysql.url"</span>), viper.Get(<span class="string">"mysql.username"</span>), viper.Get(<span class="string">"mysql.password"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序，查看效果<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go run viper_json.go</span><br><span class="line">mysql <span class="string">url:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3306</span></span><br><span class="line">mysql <span class="string">url:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3306</span></span><br><span class="line">mysql <span class="string">username:</span> root</span><br><span class="line">mysql <span class="string">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure></p><h3 id="使用viper读取yaml配置文件"><a href="#使用viper读取yaml配置文件" class="headerlink" title="使用viper读取yaml配置文件"></a>使用viper读取yaml配置文件</h3><p>假设现在有一份yaml格式的配置文件 config_yaml.yaml<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">port:</span> <span class="number">10666</span></span><br><span class="line"><span class="symbol">mysql:</span></span><br><span class="line"><span class="symbol">  url:</span> <span class="string">"127.0.0.1:3306"</span></span><br><span class="line"><span class="symbol">  username:</span> root</span><br><span class="line"><span class="symbol">  password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure></p><p>读取yaml配置文件<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/spf13/viper"</span></span><br><span class="line"><span class="string">"github.com/fsnotify/fsnotify"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">viper.SetConfigName(<span class="string">"config_yaml"</span>)     <span class="comment">//把json文件换成yaml文件，只需要配置文件名 (不带后缀)即可</span></span><br><span class="line">viper.AddConfigPath(<span class="string">"."</span>)           <span class="comment">//添加配置文件所在的路径</span></span><br><span class="line"><span class="comment">//viper.SetConfigType("json")       //设置配置文件类型</span></span><br><span class="line">err := viper.ReadInConfig()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"config file error: %s\n"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">viper.WatchConfig()           <span class="comment">//监听配置变化</span></span><br><span class="line">        viper.OnConfigChange(<span class="function"><span class="keyword">func</span><span class="params">(e fsnotify.Event)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"配置发生变更："</span>, e.Name)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">urlValue := viper.Get(<span class="string">"mysql.url"</span>)</span><br><span class="line">fmt.Println(<span class="string">"mysql url:"</span>, urlValue)</span><br><span class="line">fmt.Printf(<span class="string">"mysql url: %s\nmysql username: %s\nmysql password: %s"</span>, viper.Get(<span class="string">"mysql.url"</span>), viper.Get(<span class="string">"mysql.username"</span>), viper.GetString(<span class="string">"mysql.password"</span>))   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="viper其他重要功能"><a href="#viper其他重要功能" class="headerlink" title="viper其他重要功能"></a>viper其他重要功能</h3><p><strong>获取子级配置</strong><br>当配置层级关系较多的时候，有时候我们需要直接获取某个子级的所有配置，可以这样操作：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">app</span>:</span><br><span class="line">  <span class="attribute">cache1</span>:</span><br><span class="line">    <span class="attribute">max-items</span>: <span class="number">100</span></span><br><span class="line">    <span class="attribute">item-size</span>: <span class="number">64</span></span><br><span class="line">  <span class="attribute">cache2</span>:</span><br><span class="line">    <span class="attribute">max-items</span>: <span class="number">200</span></span><br><span class="line">    <span class="attribute">item-size</span>: <span class="number">80</span></span><br></pre></td></tr></table></figure></p><p>如果要读取cache1下的max-items，只需要执行viper.Get(“app.cache1.max-items”)就可以了。</p><p><strong>解析配置</strong><br>可以将配置绑定到某个结构体、map上，有两个方法可以做到这一点：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Unmarshal(rawVal interface&#123;&#125;) : <span class="keyword">error</span></span><br><span class="line">UnmarshalKey(key string, rawVal interface&#123;&#125;) : <span class="keyword">error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> config Config</span><br><span class="line"><span class="keyword">var</span> mysql MySQL</span><br><span class="line"><span class="keyword">err</span> := Unmarshal(&amp;config)            <span class="comment">// 将配置解析到 config 变量</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">    t.Fatalf(<span class="string">"unable to decode into struct, %v"</span>, <span class="keyword">err</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">err</span> := UnmarshalKey(<span class="string">"mysql"</span>, &amp;mysql) <span class="comment">// 将配置解析到 mysql 变量</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">    t.Fatalf(<span class="string">"unable to decode into struct, %v"</span>, <span class="keyword">err</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>获取值</strong><br>在Viper中，有一些根据值的类型获取值的方法，存在以下方法：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Get</span><span class="params">(key string)</span></span> : interface&#123;&#125;</span><br><span class="line"><span class="function"><span class="title">GetBool</span><span class="params">(key string)</span></span> : bool</span><br><span class="line"><span class="function"><span class="title">GetFloat64</span><span class="params">(key string)</span></span> : float64</span><br><span class="line"><span class="function"><span class="title">GetInt</span><span class="params">(key string)</span></span> : int</span><br><span class="line"><span class="function"><span class="title">GetString</span><span class="params">(key string)</span></span> : string</span><br><span class="line"><span class="function"><span class="title">GetStringMap</span><span class="params">(key string)</span></span> : map[string]interface&#123;&#125;</span><br><span class="line"><span class="function"><span class="title">GetStringMapString</span><span class="params">(key string)</span></span> : map[string]string</span><br><span class="line"><span class="function"><span class="title">GetStringSlice</span><span class="params">(key string)</span></span> : []string</span><br><span class="line"><span class="function"><span class="title">GetTime</span><span class="params">(key string)</span></span> : <span class="selector-tag">time</span>.Time</span><br><span class="line"><span class="function"><span class="title">GetDuration</span><span class="params">(key string)</span></span> : <span class="selector-tag">time</span>.Duration</span><br><span class="line"><span class="function"><span class="title">IsSet</span><span class="params">(key string)</span></span> : bool</span><br></pre></td></tr></table></figure></p><p>如果 Get 函数未找到值，则返回对应类型的一个零值。可以通过 IsSet() 方法来检测一个健是否存在。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">viper</span><span class="selector-class">.GetString</span>(<span class="string">"logfile"</span>) </span><br><span class="line"><span class="selector-tag">if</span> <span class="selector-tag">viper</span><span class="selector-class">.GetBool</span>(<span class="string">"verbose"</span>) &#123;</span><br><span class="line">    <span class="selector-tag">fmt</span><span class="selector-class">.Println</span>(<span class="string">"verbose enabled"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>修改对应的配置</strong><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">viper.<span class="builtin-name">Set</span>(<span class="string">"Verbose"</span>, <span class="literal">true</span>)</span><br><span class="line">viper.<span class="builtin-name">Set</span>(<span class="string">"LogFile"</span>, LogFile)</span><br></pre></td></tr></table></figure></p><h2 id="使用goconfig读取ini配置文件"><a href="#使用goconfig读取ini配置文件" class="headerlink" title="使用goconfig读取ini配置文件"></a>使用goconfig读取ini配置文件</h2><p>安装goconfig<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/Unknwon/goconfig</span><br></pre></td></tr></table></figure></p><p>假设database.conf配置文件，如下所示<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="attr">username</span>=root</span><br><span class="line"><span class="attr">password</span>=<span class="number">123456</span></span><br><span class="line"><span class="attr">url</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">3306</span></span><br><span class="line"><span class="section">[redis]</span></span><br><span class="line"><span class="attr">address</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span></span><br></pre></td></tr></table></figure></p><p>使用goconfig读取ini格式配置文件<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/Unknwon/goconfig"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cfg *goconfig.ConfigFile</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">config, err := goconfig.LoadConfigFile(<span class="string">"database.conf"</span>)    <span class="comment">//加载配置文件</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"get config file error"</span>)</span><br><span class="line">os.Exit(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">cfg = config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GlobalConfig</span><span class="params">()</span></span> &#123;</span><br><span class="line">glob, _ := cfg.GetSection(<span class="string">"mysql"</span>)      <span class="comment">//读取全部mysql配置</span></span><br><span class="line">fmt.Println(glob)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">password, _ := cfg.GetValue(<span class="string">"mysql"</span>, <span class="string">"password"</span>)  <span class="comment">//读取单个值</span></span><br><span class="line">fmt.Println(password)</span><br><span class="line">username, _ := cfg.GetValue(<span class="string">"mysql"</span>, <span class="string">"username"</span>)  <span class="comment">//读取单个值</span></span><br><span class="line">fmt.Println(username)</span><br><span class="line">err := cfg.Reload()   <span class="comment">//重载配置</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"reload config file error: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">GlobalConfig()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>加载完全局配置后，该配置长驻内存，需要动态加载的话，使用cfg.Reload()方法。</p><p>运行程序，效果如下。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run goconfig.<span class="keyword">go</span></span><br><span class="line"><span class="number">123456</span></span><br><span class="line">root</span><br><span class="line"><span class="keyword">map</span>[password:<span class="number">123456</span> ur<span class="variable">l:127</span>.<span class="number">0.0</span>.<span class="number">1</span>:<span class="number">3306</span> username:root]</span><br></pre></td></tr></table></figure></p><p>参考<br><a href="https://blog.biezhi.me/2018/10/load-config-with-viper.html" target="_blank" rel="noopener">https://blog.biezhi.me/2018/10/load-config-with-viper.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;配置工具的选择&quot;&gt;&lt;a href=&quot;#配置工具的选择&quot; class=&quot;headerlink&quot; title=&quot;配置工具的选择&quot;&gt;&lt;/a&gt;配置工具的选择&lt;/h2&gt;&lt;p&gt;通常，在一个或多个项目中会有多种格式的配置文件，比如PHP的php.ini文件、Nginx的serv
      
    
    </summary>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>使用 go cobra创建命令行项目</title>
    <link href="http://yoursite.com/2019/04/29/%E4%BD%BF%E7%94%A8-go-cobra%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2019/04/29/使用-go-cobra创建命令行项目/</id>
    <published>2019-04-29T13:59:54.000Z</published>
    <updated>2019-04-29T14:36:19.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cobra介绍"><a href="#Cobra介绍" class="headerlink" title="Cobra介绍"></a>Cobra介绍</h2><p>Cobra是一个库，其提供简单的接口来创建强大现代的CLI接口，类似于git或者go工具。同时，它也是一个应用，用来生成应用框架，从而开发以Cobra为基础的应用。Docker和Kubernetes源码中使用了Cobra。</p><p><strong>概念</strong><br>Cobra有三个基本概念commands,arguments和flags。其中commands代表行为，arguments代表数值，flags代表对行为的改变。</p><p>基本模型如下：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPNAME COMMAND ARG <span class="comment">--FLAG</span></span><br></pre></td></tr></table></figure></p><p>例如：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server是commands，port是flag</span></span><br><span class="line">hugo<span class="built_in"> server </span><span class="attribute">--port</span>=1313</span><br><span class="line"></span><br><span class="line"><span class="comment"># clone是commands，URL是arguments，brae是flags</span></span><br><span class="line">git clone URL --bare</span><br></pre></td></tr></table></figure></p><h2 id="安装cobra"><a href="#安装cobra" class="headerlink" title="安装cobra"></a>安装cobra</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span> github.<span class="keyword">com</span>/spf13/cobra/cobra</span><br></pre></td></tr></table></figure><h3 id="安装cobra可执行命令"><a href="#安装cobra可执行命令" class="headerlink" title="安装cobra可执行命令"></a>安装cobra可执行命令</h3><p>在文件夹github.com/spf13/cobra/cobra下使用go install在$GOPATH/bin路径下生成cobra.exe可执行命令。<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="keyword">install</span></span><br></pre></td></tr></table></figure></p><p>此时，可能会遇到go的一些包下载不下来的问题。由于众所周知的原因，有时会go get的时候会有一些包下载不下来，类似这样出现time out。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">https</span> fetch: Get <span class="keyword">https</span>://golang.org/x/sys/unix?go-<span class="built_in">get</span>=<span class="number">1</span>: dial tcp <span class="number">216.239</span><span class="number">.37</span><span class="number">.1</span>:<span class="number">443</span>: i/o timeout)</span><br><span class="line">(<span class="keyword">https</span> fetch: Get <span class="keyword">https</span>://golang.org/x/<span class="keyword">text</span>/transform?go-<span class="built_in">get</span>=<span class="number">1</span>: dial tcp <span class="number">216.239</span><span class="number">.37</span><span class="number">.1</span>:<span class="number">443</span>: i/o timeout)</span><br><span class="line">(<span class="keyword">https</span> fetch: Get <span class="keyword">https</span>://golang.org/x/<span class="keyword">text</span>/unicode/norm?go-<span class="built_in">get</span>=<span class="number">1</span>: dial tcp <span class="number">216.239</span><span class="number">.37</span><span class="number">.1</span>:<span class="number">443</span>: i/o timeout)</span><br></pre></td></tr></table></figure></p><p>这时候可以手动安装。进入gopath的src目录：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/go/src</span></span><br></pre></td></tr></table></figure></p><p>创建目录：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -<span class="selector-tag">p</span>  golang.org/x/</span><br></pre></td></tr></table></figure></p><p>进入刚创建的目录：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd golang<span class="meta">.org</span>/<span class="built_in">x</span></span><br></pre></td></tr></table></figure></p><p>克隆git库：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/golang/sys.git</span><br><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/golang/text.git</span><br></pre></td></tr></table></figure></p><h2 id="使用Cobra"><a href="#使用Cobra" class="headerlink" title="使用Cobra"></a>使用Cobra</h2><p>创建一个名称为demo的cobra项目，其目录为$GOPATH/src。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cobra init demo</span></span><br></pre></td></tr></table></figure></p><h3 id="实现没有子命令的CLIs程序"><a href="#实现没有子命令的CLIs程序" class="headerlink" title="实现没有子命令的CLIs程序"></a>实现没有子命令的CLIs程序</h3><p>接下来就是可以继续demo的功能设计了。例如在demo下面新建一个包，名称为imp。如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">demo</span><br><span class="line">    cmd/</span><br><span class="line">       root.go</span><br><span class="line">    imp/</span><br><span class="line">       imp.go</span><br><span class="line">   main<span class="selector-class">.go</span>       <span class="comment">//程序执行的入口，调用cmd包所以我们只需要在cmd包内调用imp包就能实现demo程序的需求</span></span><br></pre></td></tr></table></figure></p><p>imp.go文件的代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> imp</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Show</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"My Name is %s, My age is %d\n"</span>, name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>demo应用接收两个参数name和age，然后打印出来。打开cobra自动生成的root.go文件可以看到，cmd包进行了一些初始化操作并提供了Execute接口。十分简单，其中viper是cobra集成的配置文件读取的库。cobra的所有命令都是通过cobra.Command这个结构体实现的。为了实现demo功能，显然我们需要修改RootCmd。修改后的代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright © 2019 NAME HERE &lt;EMAIL ADDRESS&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment">// you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">// You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">// distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">// See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">// limitations under the License.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">homedir <span class="string">"github.com/mitchellh/go-homedir"</span></span><br><span class="line"><span class="string">"github.com/spf13/cobra"</span></span><br><span class="line"><span class="string">"github.com/spf13/viper"</span></span><br><span class="line"><span class="string">"demo/imp"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cfgFile <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rootCmd represents the base command when called without any subcommands</span></span><br><span class="line"><span class="keyword">var</span> rootCmd = &amp;cobra.Command&#123;</span><br><span class="line">Use:   <span class="string">"demo"</span>,</span><br><span class="line">Short: <span class="string">"A test demo"</span>,</span><br><span class="line">Long: <span class="string">`Demo is a test appcation for print things.`</span>,</span><br><span class="line"><span class="comment">// Uncomment the following line if your bare application</span></span><br><span class="line"><span class="comment">// has an action associated with it:</span></span><br><span class="line">Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123; </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name) == <span class="number">0</span> &#123;</span><br><span class="line">    cmd.Help()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">imp.Show(name, age)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute adds all child commands to the root command and sets flags appropriately.</span></span><br><span class="line"><span class="comment">// This is called by main.main(). It only needs to happen once to the rootCmd.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Execute</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := rootCmd.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">cobra.OnInitialize(initConfig)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here you will define your flags and configuration settings.</span></span><br><span class="line"><span class="comment">// Cobra supports persistent flags, which, if defined here,</span></span><br><span class="line"><span class="comment">// will be global for your application.</span></span><br><span class="line"><span class="comment">//rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.demo.yaml)")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cobra also supports local flags, which will only run</span></span><br><span class="line"><span class="comment">// when this action is called directly.</span></span><br><span class="line"><span class="comment">//rootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")</span></span><br><span class="line">rootCmd.Flags().StringVarP(&amp;name, <span class="string">"name"</span>, <span class="string">"n"</span>, <span class="string">""</span>, <span class="string">"person's name "</span>)</span><br><span class="line">rootCmd.Flags().IntVarP(&amp;age, <span class="string">"age"</span>, <span class="string">"a"</span>, <span class="number">0</span>, <span class="string">"person's age"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initConfig reads in config file and ENV variables if set.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initConfig</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> cfgFile != <span class="string">""</span> &#123;</span><br><span class="line"><span class="comment">// Use config file from the flag.</span></span><br><span class="line">viper.SetConfigFile(cfgFile)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Find home directory.</span></span><br><span class="line">home, err := homedir.Dir()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Search config in home directory with name ".demo" (without extension).</span></span><br><span class="line">viper.AddConfigPath(home)</span><br><span class="line">viper.SetConfigName(<span class="string">".demo"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">viper.AutomaticEnv() <span class="comment">// read in environment variables that match</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If a config file is found, read it in.</span></span><br><span class="line"><span class="keyword">if</span> err := viper.ReadInConfig(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Using config file:"</span>, viper.ConfigFileUsed())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在$GOPATH/src/demo目录下，编译demo可执行程序<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="keyword">install</span></span><br></pre></td></tr></table></figure></p><p>到此demo的功能已经实现了，我们编译运行一下看看实际效果。执行demo程序<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">demo</span></span><br><span class="line">Demo <span class="built_in">is</span> a test appcation <span class="keyword">for</span> <span class="built_in">print</span> things.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  <span class="built_in">demo</span> [flags]</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -a, --age int         person's age</span><br><span class="line">      --config <span class="built_in">string</span>   config file (default <span class="built_in">is</span> $HOME/.<span class="built_in">demo</span>.yaml)</span><br><span class="line">  -h, --help            help <span class="keyword">for</span> <span class="built_in">demo</span></span><br><span class="line">  -n, --name <span class="built_in">string</span>     person's name</span><br><span class="line">  -t, --toggle          Help message <span class="keyword">for</span> toggle</span><br></pre></td></tr></table></figure></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ demo --<span class="keyword">name</span> xiaoxu918 --age <span class="number">25</span></span><br><span class="line">My <span class="keyword">Name</span> <span class="keyword">is</span> xiaoxu918, My Age <span class="keyword">is</span> <span class="number">25</span></span><br></pre></td></tr></table></figure><h3 id="实现有子命令的CLIs程序"><a href="#实现有子命令的CLIs程序" class="headerlink" title="实现有子命令的CLIs程序"></a>实现有子命令的CLIs程序</h3><p>在$GOPATH/src/demo目录下，继续使用cobra为demo添加子命令test。<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cobra <span class="keyword">add</span><span class="bash"> <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure></p><p>在src目录下demo的文件夹下生成了一个cmd\test.go文件，如下：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">demo</span></span><br><span class="line">    cmd/</span><br><span class="line">       root.<span class="built_in">go</span></span><br><span class="line">       test.<span class="built_in">go</span></span><br><span class="line">   main.<span class="built_in">go</span></span><br></pre></td></tr></table></figure></p><p>更新编译demo应用<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="keyword">install</span></span><br></pre></td></tr></table></figure></p><p>接下来的操作就和上面修改root.go文件一样去配置test子命令，此处不再赘述，查看效果<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">demo</span></span><br></pre></td></tr></table></figure></p><p>可以看出demo既支持直接使用标记flag，又能使用子命令<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo <span class="keyword">test</span> -<span class="built_in">h</span></span><br></pre></td></tr></table></figure></p><h3 id="附加命令"><a href="#附加命令" class="headerlink" title="附加命令"></a>附加命令</h3><p>附加命令可以在/cmd/文件夹中写，例如一个版本信息文件，可以创建/cmd/version.go。代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/spf13/cobra"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">rootCmd.AddCommand(versionCmd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> versionCmd = &amp;cobra.Command&#123;</span><br><span class="line">Use:   <span class="string">"version"</span>,</span><br><span class="line">Short: <span class="string">"Print the version number of Demo"</span>,</span><br><span class="line">Long:  <span class="string">`All software has versions. This is demo's`</span>,</span><br><span class="line">Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Demo Version: v1.0"</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更新编译demo应用<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">go</span> install</span><br><span class="line"><span class="built_in">demo</span></span><br></pre></td></tr></table></figure></p><p>测试一下。当然，建议版本信息使用flag实现。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">demo <span class="keyword">version</span></span><br><span class="line">Demo <span class="keyword">Version</span>: v1.<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>参考：<br><a href="https://o-my-chenjian.com/2017/09/20/Using-Cobra-With-Golang/" target="_blank" rel="noopener">https://o-my-chenjian.com/2017/09/20/Using-Cobra-With-Golang/</a><br><a href="https://studygolang.com/articles/7588" target="_blank" rel="noopener">https://studygolang.com/articles/7588</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Cobra介绍&quot;&gt;&lt;a href=&quot;#Cobra介绍&quot; class=&quot;headerlink&quot; title=&quot;Cobra介绍&quot;&gt;&lt;/a&gt;Cobra介绍&lt;/h2&gt;&lt;p&gt;Cobra是一个库，其提供简单的接口来创建强大现代的CLI接口，类似于git或者go工具。同时，它也
      
    
    </summary>
    
      <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>使用go flag解析命令行参数</title>
    <link href="http://yoursite.com/2019/04/29/%E4%BD%BF%E7%94%A8go-flag%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2019/04/29/使用go-flag解析命令行参数/</id>
    <published>2019-04-29T13:59:38.000Z</published>
    <updated>2019-04-29T14:43:26.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="flag-包概述"><a href="#flag-包概述" class="headerlink" title="flag 包概述"></a>flag 包概述</h2><p>flag 包实现了命令行参数的解析。定义 flags 有三种方式</p><h3 id="1）flag-Xxx-，其中-Xxx-可以是-Int、String，Bool-等，返回一个相应类型的指针，如："><a href="#1）flag-Xxx-，其中-Xxx-可以是-Int、String，Bool-等，返回一个相应类型的指针，如：" class="headerlink" title="1）flag.Xxx()，其中 Xxx 可以是 Int、String，Bool 等，返回一个相应类型的指针，如："></a>1）flag.Xxx()，其中 Xxx 可以是 Int、String，Bool 等，返回一个相应类型的指针，如：</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var<span class="built_in"> ip </span>= flag.Int(<span class="string">"flagname"</span>, 1234, <span class="string">"help message for flagname"</span>)</span><br></pre></td></tr></table></figure><p>第一个参数 ：flag名称为flagname<br>第二个参数 ：flagname默认值为1234<br>第三个参数 ：flagname的提示信息</p><p>返回的ip是指针类型，所以这种方式获取ip的值应该fmt.Println(*ip)</p><h3 id="2）flag-XxxVar-，将-flag-绑定到一个变量上，如："><a href="#2）flag-XxxVar-，将-flag-绑定到一个变量上，如：" class="headerlink" title="2）flag.XxxVar()，将 flag 绑定到一个变量上，如："></a>2）flag.XxxVar()，将 flag 绑定到一个变量上，如：</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flagValue <span class="keyword">int</span></span><br><span class="line">flag.IntVar(&amp;flagValue, <span class="string">"flagname"</span>, <span class="number">1234</span>, <span class="string">"help message for flagname"</span>)</span><br></pre></td></tr></table></figure><p>第一个参数 ：接收flagname的实际值<br>第二个参数 ：flag名称为flagname<br>第三个参数 ：flagname默认值为1234<br>第四个参数 ：flagname的提示信息</p><p>这种方式获取ip的值fmt.Println(ip)就可以了：</p><h3 id="3）自定义flag"><a href="#3）自定义flag" class="headerlink" title="3）自定义flag"></a>3）自定义flag</h3><p>另外，还可以自定义 flag，只要实现 flag.Value 接口即可（要求 receiver 是指针），形如：<br><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello Hello</span><br><span class="line">flag.<span class="keyword">Var</span>(&amp;hello, <span class="string">"hello"</span>, <span class="string">"hello参数"</span>)</span><br></pre></td></tr></table></figure></p><h2 id="安装spf13-pflag"><a href="#安装spf13-pflag" class="headerlink" title="安装spf13/pflag"></a>安装spf13/pflag</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/spf13/pflag</span><br></pre></td></tr></table></figure><p>代码如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义flags</span></span><br><span class="line"><span class="keyword">var</span> inputName = flag.String(<span class="string">"name"</span>, <span class="string">"XuChao"</span>, <span class="string">"Input your name"</span>)</span><br><span class="line"><span class="keyword">var</span> inputAge = flag.Int(<span class="string">"age"</span>, <span class="number">25</span>, <span class="string">"Input your age"</span>)</span><br><span class="line"><span class="keyword">var</span> inputGender = flag.String(<span class="string">"gender"</span>, <span class="string">"boy"</span>, <span class="string">"Input your gender"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">flag.Parse()     <span class="comment">//flag解析</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i != flag.NArg(); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"arg[%d]=%s\n"</span>, i, flag.Arg(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"name="</span>, *inputName)</span><br><span class="line">fmt.Println(<span class="string">"age="</span>, *inputAge)</span><br><span class="line">fmt.Println(<span class="string">"gender="</span>, *inputGender)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用flag"><a href="#使用flag" class="headerlink" title="使用flag"></a>使用flag</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build flag.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./flag -h</span><br><span class="line">Usage of C:\Users\Administrator\<span class="keyword">go</span>\src\flag.exe:</span><br><span class="line">  -age <span class="keyword">int</span></span><br><span class="line">        Input your age (<span class="keyword">default</span> <span class="number">25</span>)</span><br><span class="line">  -gender <span class="keyword">string</span></span><br><span class="line">        Input your gender (<span class="keyword">default</span> <span class="string">"boy"</span>)</span><br><span class="line">  -name <span class="keyword">string</span></span><br><span class="line">        Input your name (<span class="keyword">default</span> <span class="string">"XuChao"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./flag  xuchao</span><br><span class="line">arg[0]=xuchao</span><br><span class="line">name= XuChao</span><br><span class="line">age= 25</span><br><span class="line">gender= boy</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./flag  -name balbalba -age 1111 dfdf xccccc eette</span><br><span class="line">arg[0]=dfdf</span><br><span class="line">arg[1]=xccccc</span><br><span class="line">arg[2]=eette</span><br><span class="line">name= balbalba</span><br><span class="line">age= 1111</span><br><span class="line">gender= boy</span><br></pre></td></tr></table></figure><h2 id="自定义参数类型flag："><a href="#自定义参数类型flag：" class="headerlink" title="自定义参数类型flag："></a>自定义参数类型flag：</h2><p>例如，解析我喜欢的编程语言，我们希望直接解析到 slice 中，我们可以定义如下 sliceValue类型，然后实现Value接口。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个类型，用于增加该类型方法</span></span><br><span class="line"><span class="keyword">type</span> sliceValue []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//new一个存放命令行参数值的slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSliceValue</span><span class="params">(vals []<span class="keyword">string</span>, p *[]<span class="keyword">string</span>)</span> *<span class="title">sliceValue</span></span> &#123;</span><br><span class="line">    *p = vals</span><br><span class="line">    <span class="keyword">return</span> (*sliceValue)(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Value接口：</span></span><br><span class="line"><span class="comment">type Value interface &#123;</span></span><br><span class="line"><span class="comment">    String() string</span></span><br><span class="line"><span class="comment">    Set(string) error</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">实现flag包中的Value接口，将命令行接收到的值用,分隔存到slice里</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sliceValue)</span> <span class="title">Set</span><span class="params">(val <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    *s = sliceValue(strings.Split(val, <span class="string">","</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//flag为slice的默认值default is me,和return返回值没有关系</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sliceValue)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    *s = sliceValue(strings.Split(<span class="string">"default is me"</span>, <span class="string">","</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"It's none of my business"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可执行文件名 -slice="java,go"  最后将输出[java,go]</span></span><br><span class="line"><span class="comment">可执行文件名 最后将输出[default is me]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> languages []<span class="keyword">string</span></span><br><span class="line">    flag.Var(newSliceValue([]<span class="keyword">string</span>&#123;&#125;, &amp;languages), <span class="string">"slice"</span>, <span class="string">"I like programming `languages`"</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印结果slice接收到的值</span></span><br><span class="line">    fmt.Println(languages)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样通过 -slice “go,php” 这样的形式传递参数，languages 得到的就是 [go, php]。如果不加-slice参数则打印默认值[default is me]。</p><p>参考：<br><a href="https://www.cnblogs.com/chenqionghe/p/8295807.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenqionghe/p/8295807.html</a><br><a href="https://www.jianshu.com/p/f9cf46a4de0e" target="_blank" rel="noopener">https://www.jianshu.com/p/f9cf46a4de0e</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;flag-包概述&quot;&gt;&lt;a href=&quot;#flag-包概述&quot; class=&quot;headerlink&quot; title=&quot;flag 包概述&quot;&gt;&lt;/a&gt;flag 包概述&lt;/h2&gt;&lt;p&gt;flag 包实现了命令行参数的解析。定义 flags 有三种方式&lt;/p&gt;
&lt;h3 id=&quot;1
      
    
    </summary>
    
      <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>如何实现K8s Pod核心指标弹性伸缩</title>
    <link href="http://yoursite.com/2019/04/19/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0K8s-Pod%E6%A0%B8%E5%BF%83%E6%8C%87%E6%A0%87%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9/"/>
    <id>http://yoursite.com/2019/04/19/如何实现K8s-Pod核心指标弹性伸缩/</id>
    <published>2019-04-19T15:44:46.000Z</published>
    <updated>2019-04-19T16:13:18.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Metrics-server简介"><a href="#Metrics-server简介" class="headerlink" title="Metrics-server简介"></a>Metrics-server简介</h2><p>Pod核心指标是相对于自定义指标而言的，也就是指通过采集Pod CPU、内存等核心资源指标实现Pod弹性伸缩。Metrics-server是用来替换heapster获取集群资源指标数据的服务，heapster从1.11开始逐渐被废弃了。</p><p>metrics-server，是一种API Server，提供了核心的Metrics API，就像k8s组件kube-apiserver提供了很多API群组一样，但它不是k8s组成部分，而是托管运行在k8s之上的Pod。为了让用户无缝的使用metrics-server当中的API，还需要把这类自定义的API，通过聚合器聚合到核心API组里，然后把此API当作是核心API的一部分，通过kubectl api-versions可直接查看。Metrics server是K8S集群资源使用情况的聚合器。<br><img src="/images/k8s-metrics-01.png" alt="image">                                                                </p><p>metrics-server收集指标数据的方式是从各节点上kubelet提供的Summary API 即10250端口收集数据，收集Node和Pod核心资源指标数据，主要是内存和cpu方面的使用情况，并将收集的信息存储在内存中，所以通过kubectl top不能查看资源数据的历史情况，其它资源指标数据则通过prometheus采集。<br><img src="/images/k8s-metrics-02.png" alt="image"></p><p>k8s中很多组件是依赖于资源指标API的功能 ，比如kubectl top 、hpa，如果没有一个资源指标API接口，这些组件是没法运行的。</p><h2 id="安装metrics-server"><a href="#安装metrics-server" class="headerlink" title="安装metrics-server"></a>安装metrics-server</h2><p>下载该链接目录下的六个文件(说明：因为我安装的K8s版本是1.13.1，故此使用的对应分支也是1.13.1)。<br><a href="https://github.com/kubernetes/kubernetes/blob/v1.13.1/cluster/addons/metrics-server/" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/blob/v1.13.1/cluster/addons/metrics-server/</a></p><p>查看下载的资源清单文件<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ls metrics-server/</span></span><br><span class="line">auth-delegator.yaml      metrics-<span class="keyword">server</span>-deployment.yaml     resource-reader.yaml</span><br><span class="line">auth-reader.yaml          metrics-<span class="keyword">server</span>-service.yaml</span><br><span class="line">metrics-apiservice.yaml</span><br></pre></td></tr></table></figure></p><p>修改配置<br>下载下来的文件不能直接部署，有几处需要修改。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vim metrics-server-deployment.yaml</span><br><span class="line"><span class="symbol">image:</span> k8s.gcr.io/metrics-server-amd64:v0<span class="meta">.3</span><span class="meta">.1</span> </span><br><span class="line">//修改为image: xiaoxu780/metrics-server-amd64:v0<span class="meta">.3</span><span class="meta">.1</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">image:</span> k8s.gcr.io/addon-resizer:<span class="number">1.8</span><span class="meta">.4</span></span><br><span class="line">//修改为image: xiaoxu780/addon-resizer:<span class="number">1.8</span><span class="meta">.1</span></span><br></pre></td></tr></table></figure></p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># vim resource-reader.yaml</span><br><span class="line">rules:</span><br><span class="line">-<span class="ruby"> <span class="symbol">apiGroups:</span></span></span><br><span class="line"><span class="ruby">  - <span class="string">""</span></span></span><br><span class="line"><span class="ruby">  <span class="symbol">resources:</span></span></span><br><span class="line"><span class="ruby">  - pods</span></span><br><span class="line"><span class="ruby">  - nodes</span></span><br><span class="line"><span class="ruby">  - nodes/stats    <span class="comment">#新增这一行</span></span></span><br><span class="line"><span class="ruby">  - namespaces</span></span><br></pre></td></tr></table></figure><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># vim metrics-server-deployment.yaml</span><br><span class="line">#修改containers metrics-server 启动参数，修改好的如下：</span><br><span class="line"> containers:</span><br><span class="line">      -<span class="ruby"> <span class="symbol">name:</span> metrics-server</span></span><br><span class="line"><span class="ruby">        <span class="symbol">image:</span> k8s.gcr.io/metrics-server-<span class="symbol">amd64:</span>v<span class="number">0</span>.<span class="number">3.1</span></span></span><br><span class="line"><span class="ruby">        <span class="symbol">command:</span></span></span><br><span class="line"><span class="ruby">        - <span class="regexp">/metrics-server</span></span></span><br><span class="line"><span class="ruby">        - --metric-resolution=<span class="number">30</span>s</span></span><br><span class="line"><span class="ruby">        - --kubelet-insecure-tls    /<span class="regexp">/表示不验证kubelet API服务的HTTPS证书</span></span></span><br><span class="line"><span class="ruby">        - --kubelet-preferred-address-types=InternalIP,Hostname,InternalDNS,ExternalDNS,ExternalIP</span></span><br><span class="line"><span class="ruby">        <span class="comment"># These are needed for GKE, which doesn't support secure communication yet.</span></span></span><br><span class="line"><span class="ruby">        <span class="comment"># Remove these lines for non-GKE clusters, and when GKE supports token-based auth.</span></span></span><br><span class="line"><span class="ruby">        <span class="comment">#- --kubelet-port=10255</span></span></span><br><span class="line"><span class="ruby">        <span class="comment">#- --deprecated-kubelet-completely-insecure=true</span></span></span><br><span class="line"><span class="ruby">----            </span></span><br><span class="line"><span class="ruby"><span class="comment"># 修改containers，metrics-server-nanny 启动参数，修改好的如下：</span></span></span><br><span class="line"><span class="ruby"><span class="symbol">command:</span></span></span><br><span class="line"><span class="ruby">          - <span class="regexp">/pod_nanny</span></span></span><br><span class="line"><span class="ruby">          - --config-dir=<span class="regexp">/etc/config</span></span></span><br><span class="line"><span class="ruby">          - --cpu=<span class="number">80</span>m</span></span><br><span class="line"><span class="ruby">          - --extra-cpu=<span class="number">0</span>.<span class="number">5</span>m</span></span><br><span class="line"><span class="ruby">          - --memory=<span class="number">80</span>Mi</span></span><br><span class="line"><span class="ruby">          - --extra-memory=<span class="number">8</span>Mi</span></span><br><span class="line"><span class="ruby">          - --threshold=<span class="number">5</span></span></span><br><span class="line"><span class="ruby">          - --deployment=metrics-server-v<span class="number">0</span>.<span class="number">3.1</span></span></span><br><span class="line"><span class="ruby">          - --container=metrics-server</span></span><br><span class="line"><span class="ruby">          - --poll-period=<span class="number">300000</span></span></span><br><span class="line"><span class="ruby">          - --estimator=exponential</span></span><br><span class="line"><span class="ruby">          <span class="comment"># Specifies the smallest cluster (defined in number of nodes)</span></span></span><br><span class="line"><span class="ruby">          <span class="comment"># resources will be scaled to.</span></span></span><br><span class="line"><span class="ruby">          <span class="comment">#- --minClusterSize=&#123;&#123; metrics_server_min_cluster_size &#125;&#125;</span></span></span><br></pre></td></tr></table></figure><p>应用到集群<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># kubectl create -f ./</span></span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/metrics-<span class="keyword">server</span>:system:auth-delegator created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/metrics-<span class="keyword">server</span>-auth-reader created</span><br><span class="line">apiservice.apiregistration.k8s.io/v1beta1.metrics.k8s.io created</span><br><span class="line">serviceaccount/metrics-<span class="keyword">server</span> created</span><br><span class="line">configmap/metrics-<span class="keyword">server</span>-config created</span><br><span class="line">deployment.extensions/metrics-<span class="keyword">server</span>-v0<span class="number">.3</span><span class="number">.1</span> created</span><br><span class="line">service/metrics-<span class="keyword">server</span> created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/system:metrics-<span class="keyword">server</span> created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/system:metrics-<span class="keyword">server</span> created</span><br></pre></td></tr></table></figure></p><h2 id="验证metrics-server"><a href="#验证metrics-server" class="headerlink" title="验证metrics-server"></a>验证metrics-server</h2><p>查看是否成功运行<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#  kubectl get pod -n kube-system </span><br><span class="line">NAME                                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">metrics-server-v0<span class="number">.3</span><span class="number">.1</span><span class="number">-75</span>d77b57cd-hlwlh     <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">0</span>          <span class="number">3</span>m</span><br></pre></td></tr></table></figure></p><p>查看api<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl api-versions | grep metrics-server</span></span><br><span class="line">metrics.k8s.io/v1beta1</span><br></pre></td></tr></table></figure></p><p>查看Metrics API数据，启动一个代理以便curl api<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl proxy --port=8091</span></span><br><span class="line">Starting <span class="keyword">to</span> serve <span class="keyword">on</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8091</span></span><br></pre></td></tr></table></figure></p><p>直接查看接口数据，可获取的资源：nodes和pods<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># curl localhost:8091/apis/metrics.k8s.io/v1beta1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"kind"</span>: <span class="string">"APIResourceList"</span>,</span><br><span class="line">  <span class="string">"apiVersion"</span>: <span class="string">"v1"</span>,</span><br><span class="line">  <span class="string">"groupVersion"</span>: <span class="string">"metrics.k8s.io/v1beta1"</span>,</span><br><span class="line">  <span class="string">"resources"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"nodes"</span>,</span><br><span class="line">      <span class="string">"singularName"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="string">"namespaced"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">"kind"</span>: <span class="string">"NodeMetrics"</span>,</span><br><span class="line">      <span class="string">"verbs"</span>: [</span><br><span class="line">        <span class="string">"get"</span>,</span><br><span class="line">        <span class="string">"list"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"pods"</span>,</span><br><span class="line">      <span class="string">"singularName"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="string">"namespaced"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">"kind"</span>: <span class="string">"PodMetrics"</span>,</span><br><span class="line">      <span class="string">"verbs"</span>: [</span><br><span class="line">        <span class="string">"get"</span>,</span><br><span class="line">        <span class="string">"list"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><p>查看获取到的Node资源指标数据：cpu和内存<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># curl localhost:<span class="number">8091</span><span class="regexp">/apis/m</span>etrics.k8s.io<span class="regexp">/v1beta1/</span>nodes</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"kind"</span>: <span class="string">"NodeMetricsList"</span>,</span><br><span class="line">  <span class="string">"apiVersion"</span>: <span class="string">"metrics.k8s.io/v1beta1"</span>,</span><br><span class="line">  <span class="string">"metadata"</span>: &#123;</span><br><span class="line">    <span class="string">"selfLink"</span>: <span class="string">"/apis/metrics.k8s.io/v1beta1/nodes"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"items"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"metadata"</span>: &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"k8s-node02"</span>,</span><br><span class="line">        <span class="string">"selfLink"</span>: <span class="string">"/apis/metrics.k8s.io/v1beta1/nodes/k8s-node02"</span>,</span><br><span class="line">        <span class="string">"creationTimestamp"</span>: <span class="string">"2018-10-06T08:48:51Z"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"timestamp"</span>: <span class="string">"2018-10-06T08:48:23Z"</span>,</span><br><span class="line">      <span class="string">"window"</span>: <span class="string">"30s"</span>,</span><br><span class="line">      <span class="string">"usage"</span>: &#123;</span><br><span class="line">        <span class="string">"cpu"</span>: <span class="string">"118493217n"</span>,</span><br><span class="line">        <span class="string">"memory"</span>: <span class="string">"1320848Ki"</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>kubectl top查看<br>既然通过接口查看到了数据，就可以使用kubectl top直接查看了。<br>查看node<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># kubectl top node </span><br><span class="line">NAME   CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%   </span><br><span class="line">k8s    <span class="number">135</span>m         <span class="number">1</span>%     <span class="number">2476</span>Mi          <span class="number">7</span>%</span><br></pre></td></tr></table></figure></p><p>查看pod<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># kubectl top pods -n kube-system</span><br><span class="line">NAME                                       CPU(cores)   MEMORY(bytes)   </span><br><span class="line">calico-kube-controllers<span class="number">-687</span>b7cc79c-knj87   <span class="number">1</span>m           <span class="number">12</span>Mi            </span><br><span class="line">calico-node<span class="number">-7</span>rj8c                          <span class="number">13</span>m          <span class="number">33</span>Mi            </span><br><span class="line">coredns<span class="number">-5</span>b47d4476c<span class="number">-8</span>wdb7                   <span class="number">2</span>m           <span class="number">20</span>Mi            </span><br><span class="line">coredns<span class="number">-5</span>b47d4476c<span class="number">-92</span>wnq                   <span class="number">2</span>m           <span class="number">19</span>Mi            </span><br><span class="line">dns-autoscaler<span class="number">-5</span>b547856bc<span class="number">-95</span>cft            <span class="number">1</span>m           <span class="number">10</span>Mi            </span><br><span class="line">kube-apiserver-k8s                         <span class="number">19</span>m          <span class="number">410</span>Mi           </span><br><span class="line">kube-controller-manager-k8s                <span class="number">34</span>m          <span class="number">68</span>Mi            </span><br><span class="line">kube-proxy-cdlzp                           <span class="number">2</span>m           <span class="number">29</span>Mi            </span><br><span class="line">kube-scheduler-k8s                         <span class="number">8</span>m           <span class="number">22</span>Mi            </span><br><span class="line">kubernetes-dashboard-d7978b5cc-lvf6l       <span class="number">1</span>m           <span class="number">21</span>Mi            </span><br><span class="line">metrics-server-v0<span class="number">.3</span><span class="number">.1</span><span class="number">-584</span>d9c57d4-cbkw2     <span class="number">1</span>m           <span class="number">28</span>Mi</span><br></pre></td></tr></table></figure></p><p>Metrics Server从Kubernetes集群中每个Node上kubelet的API收集metrics数据。通过Metrics API可以获取Kubernetes资源的Metrics指标，Metrics API挂载/apis/metrics.k8s.io/ 下。 可以使用kubectl top命令访问Metrics API，例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#  kubectl get --raw <span class="meta-string">"/apis/metrics.k8s.io/v1beta1/nodes"</span></span></span><br><span class="line">&#123;<span class="string">"kind"</span>:<span class="string">"NodeMetricsList"</span>,<span class="string">"apiVersion"</span>:<span class="string">"metrics.k8s.io/v1beta1"</span>,<span class="string">"metadata"</span>:&#123;<span class="string">"selfLink"</span>:<span class="string">"/apis/metrics.k8s.io/v1beta1/nodes"</span>&#125;,<span class="string">"items"</span>:[&#123;<span class="string">"metadata"</span>:&#123;<span class="string">"name"</span>:<span class="string">"k8s"</span>,<span class="string">"selfLink"</span>:<span class="string">"/apis/metrics.k8s.io/v1beta1/nodes/k8s"</span>,<span class="string">"creationTimestamp"</span>:<span class="string">"2019-01-07T15:25:55Z"</span>&#125;,<span class="string">"timestamp"</span>:<span class="string">"2019-01-07T15:25:52Z"</span>,<span class="string">"window"</span>:<span class="string">"30s"</span>,<span class="string">"usage"</span>:&#123;<span class="string">"cpu"</span>:<span class="string">"135838412n"</span>,<span class="string">"memory"</span>:<span class="string">"2532372Ki"</span>&#125;&#125;]&#125;</span><br></pre></td></tr></table></figure></p><p>metrics-server已经可以正常工作了，核心指标已经获取到了，其它的自定义指标获取则要借助于prometheus了。</p><p>k8s v1.10版本之前仍然要通过heapster获取指标数据，否则即使部署了metrics-server，kubectl top这个指令仍然连接heapster。</p><h2 id="HPA介绍和使用"><a href="#HPA介绍和使用" class="headerlink" title="HPA介绍和使用"></a>HPA介绍和使用</h2><p>HPA是k8s一个非常强大的功能，根据Pod的cpu、内存及其它指标自动伸缩Pod副本数量，HPA目前有两个版本，通过kubectl api-versions查看：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl api-versions | grep autoscal</span></span><br><span class="line">autoscaling/v1</span><br><span class="line">autoscaling/v2beta1</span><br><span class="line">autoscaling/v2beta2</span><br></pre></td></tr></table></figure></p><ul><li>autoscaling/v1：仅支持核心指标API，目前是由metrics-service提供的metrics.k8s.io/v1beta1，提供的指标来定义，也就是cpu和内存，而内存是不可压缩型资源，不支持弹性缩放，所以只能支持cpu指标来弹性伸缩。</li><li>autoscaling/v2：除了核心指标之外，还支持定义自定义指标，目前是由custom-metrics-apiserver服务提供的custom.metrics.k8s.io/v1beta1，比如内存、网络方面的指标，前提是配置了自定义指标API服务。</li></ul><p>下面创建一个Pod，然后创建一个HPA监控Pod的CPU使用率，再对Pod实施压测，查看HPA是否根据Pod的cpu使用率伸缩Pod副本。</p><p>创建一个Pod<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl run php-apache --image=k8s.gcr.io/hpa-example --requests=cpu=200m --expose --port=80</span></span><br><span class="line">service/php-apache created</span><br><span class="line">deployment.apps/php-apache created</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># kubectl get pod -o wide</span></span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE   <span class="built_in"> IP </span>              NODE         NOMINATED NODE</span><br><span class="line">php-apache-b5f58cc5f-6csfw   1/1     Running   0          28s    192.168.85.198   k8s-node01   &lt;none&gt;</span><br></pre></td></tr></table></figure></p><p>定义HPA<br>HPA监控目标对象的cpu使用率，确保所有副本的Pod的CPU使用不超50%, 并适当的进行伸缩。<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">kubectl</span> <span class="comment">autoscale</span> <span class="comment">deployment</span> <span class="comment">php</span><span class="literal">-</span><span class="comment">apache</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">cpu</span><span class="literal">-</span><span class="comment">percent=50</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">min=1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">max=10</span></span><br><span class="line"><span class="comment">horizontalpodautoscaler</span><span class="string">.</span><span class="comment">autoscaling/php</span><span class="literal">-</span><span class="comment">apache</span> <span class="comment">autoscaled</span></span><br></pre></td></tr></table></figure></p><p>当前为0%<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get hpa</span><br><span class="line">NAME         REFERENCE               TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">php-apache   Deployment/php-apache   <span class="number">0</span>%/<span class="number">50</span>%    <span class="number">1</span>         <span class="number">10</span>        <span class="number">1</span>          <span class="number">30</span>s</span><br></pre></td></tr></table></figure></p><p>启动一个程序对其压测<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># kubectl run -i --tty <span class="keyword">load</span>-generator --image=busybox /bin/sh</span><br><span class="line">/ # while <span class="keyword">true</span><span class="comment">; do wget -q -O- http://php-apache.default.svc.cluster.local; done</span></span><br><span class="line"><span class="comment">OK!OK!OK!OK!OK!OK!OK!OK!OK!OK!OK!OK!OK!OK!OK!OK!OK!OK!OK!OK!OK!OK!OK!OK!OK!OK!OK</span></span><br></pre></td></tr></table></figure></p><p>等一会查看hpa<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get hpa</span><br><span class="line">NAME         REFERENCE               TARGETS    MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">php-apache   Deployment/php-apache   <span class="number">481</span>%/<span class="number">50</span>%   <span class="number">1</span>         <span class="number">10</span>        <span class="number">1</span>          <span class="number">21</span>m</span><br></pre></td></tr></table></figure></p><p>POD的cpu占用率已达481%，因此hpa控制器自动将pod副本调整到了10个。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get deployments php-apache </span><br><span class="line">NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">php-apache   <span class="number">10</span>        <span class="number">10</span>        <span class="number">10</span>           <span class="number">10</span>          <span class="number">25</span>m</span><br></pre></td></tr></table></figure><p>停止压测，过几分钟后查看，HPA自动缩减至1个。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get hpa</span><br><span class="line">NAME         REFERENCE               TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">php-apache   Deployment/php-apache   <span class="number">0</span>%/<span class="number">50</span>%    <span class="number">1</span>         <span class="number">10</span>        <span class="number">1</span>          <span class="number">39</span>m</span><br><span class="line"></span><br><span class="line"># kubectl get deployments php-apache </span><br><span class="line">NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">php-apache   <span class="number">1</span>         <span class="number">1</span>         <span class="number">1</span>            <span class="number">1</span>           <span class="number">39</span></span><br></pre></td></tr></table></figure></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1.通过Metrics API我们可以获取到指定node或者pod的当前资源使用情况，但是该服务并不存储任何信息也不支持其他后端存储，所以我们不可能通过Metrics API来获取资源的历史使用情况。<br>2.由于Metrics Server只能获取核心资源指标，对于其他指标（如网络、HTTP等），还得使用prometheus，并实现数据持久化存储。</p><p>参考资料<br><a href="http://blog.51cto.com/newfly/2294112" target="_blank" rel="noopener">http://blog.51cto.com/newfly/2294112</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Metrics-server简介&quot;&gt;&lt;a href=&quot;#Metrics-server简介&quot; class=&quot;headerlink&quot; title=&quot;Metrics-server简介&quot;&gt;&lt;/a&gt;Metrics-server简介&lt;/h2&gt;&lt;p&gt;Pod核心指标是相对于自定义
      
    
    </summary>
    
      <category term="Kubernetes" scheme="http://yoursite.com/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="http://yoursite.com/tags/Kubernetes/"/>
    
      <category term="自动弹性伸缩" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>Ceph安装和离线源制作(mimic版本)</title>
    <link href="http://yoursite.com/2019/03/22/Ceph%E7%A6%BB%E7%BA%BF%E6%BA%90%E5%88%B6%E4%BD%9C-mimic%E7%89%88%E6%9C%AC/"/>
    <id>http://yoursite.com/2019/03/22/Ceph离线源制作-mimic版本/</id>
    <published>2019-03-22T11:48:52.000Z</published>
    <updated>2019-03-26T14:02:52.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>系统：Centos 7（系统最小化安装）<br>版本：Ceph mimic</p><h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><p>配置主机名hostname、hosts、关闭firewalld、ssh无密码登录、ntp时间同步等，过程略。</p><p>保存下载rpm包，安装或升级的同时保留RPM包。yum 默认情况下，升级或者安装后会删除下载的rpm包。不过，我们也可以设置不删除下载的rpm包。<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim/etc/yum.conf</span><br><span class="line">[main]</span><br><span class="line">cachedir=/var/cache/yum</span><br><span class="line">keepcache=0</span><br></pre></td></tr></table></figure></p><p>将 keepcache=0 修改为 keepcache=1， 安装或者升级后，在目录 /var/cache/yum 下就会有下载的 rpm 包了。</p><p>配置源，使用阿里源<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -f <span class="string">/etc/yum.repos.d/</span>*</span><br><span class="line">wget -O <span class="string">/etc/yum.repos.d/CentOS-Base.repo</span> http:<span class="string">//mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line">wget -O <span class="string">/etc/yum.repos.d/epel.repo</span> http:<span class="string">//mirrors.aliyun.com/repo/epel-7.repo</span></span><br></pre></td></tr></table></figure></p><p>删除阿里内网地址<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -<span class="selector-tag">i</span> <span class="string">'/aliyuncs.com/d'</span> /etc/yum<span class="selector-class">.repos</span><span class="selector-class">.d</span><span class="comment">/*.repo</span></span><br></pre></td></tr></table></figure></p><p>创建ceph源<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">echo '</span><br><span class="line">[ceph-noarch]</span><br><span class="line">name=Ceph noarch packages</span><br><span class="line">baseurl=https://mirrors.aliyun.com/ceph/rpm-mimic/el7/noarch</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">priority=1</span><br><span class="line">type=rpm-md</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/ceph/keys/release.asc</span><br><span class="line">'&gt;/etc/yum.repos.d/ceph.repo</span><br></pre></td></tr></table></figure></p><p>生成缓存<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean all <span class="meta">&amp;&amp; yum makecache</span></span><br></pre></td></tr></table></figure></p><p>指定安装版本的源<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">CEPH_DEPLOY_REPO_URL</span>=https://mirrors.aliyun.com/ceph/rpm-mimic/el7</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">CEPH_DEPLOY_GPG_URL</span>=https://mirrors.aliyun.com/ceph/keys/release.asc</span><br></pre></td></tr></table></figure></p><h2 id="安装Ceph"><a href="#安装Ceph" class="headerlink" title="安装Ceph"></a>安装Ceph</h2><p>ceph-node1：Ceph mon+osd节点<br>ceph-node2：Ceph mon+osd节点<br>ceph-node3；Ceph mon+osd节点</p><p>安装ceph-deploy配置工具<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> -y ceph-deploy</span><br></pre></td></tr></table></figure></p><p>创建配置目录<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="string">/etc/ceph</span> &amp;&amp; <span class="keyword">cd</span> <span class="string">/etc/ceph/</span></span><br></pre></td></tr></table></figure></p><p>初始化Mon配置<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy new --public-network <span class="number">192.168</span><span class="number">.111</span><span class="number">.0</span>/<span class="number">24</span> ceph-node&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p><p>配置网络,单网卡忽略 修改冗余份数为2，日志大小2G<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">echo '</span><br><span class="line">mon_clock_drift_allowed = 2    </span><br><span class="line">osd_journal_size = 4086</span><br><span class="line">osd_pool_default_pg_num = 128</span><br><span class="line">osd_pool_default_pgp_num = 128</span><br><span class="line">osd pool default size = 2</span><br><span class="line">osd pool default min size = 1</span><br><span class="line">rbd_default_features = 1</span><br><span class="line">client_quota = true</span><br><span class="line">'&gt;&gt;./ceph.conf</span><br></pre></td></tr></table></figure></p><p>安装Ceph<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy install --release mimic ceph-admin ceph-<span class="keyword">node</span><span class="title">&#123;1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p><p>初始化monitor和key<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy <span class="comment">--overwrite-conf mon create-initial</span></span><br></pre></td></tr></table></figure></p><p>分发拷贝配置及密钥<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">644</span> /etc/ceph/ceph.client.admin.keyring</span><br><span class="line">ceph-deploy admin ceph-admin ceph-<span class="keyword">node</span><span class="title">&#123;1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p><p>创建存储节点，清空磁盘<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy disk zap ceph-node1 <span class="regexp">/dev/</span>vdb</span><br><span class="line">ceph-deploy disk zap ceph-node2 <span class="regexp">/dev/</span>vdb</span><br><span class="line">ceph-deploy disk zap ceph-node3 <span class="regexp">/dev/</span>vdb</span><br></pre></td></tr></table></figure></p><p>查看可用磁盘<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy disk <span class="built_in">list</span> ceph-node1</span><br><span class="line">ceph-deploy disk <span class="built_in">list</span> ceph-node2</span><br><span class="line">ceph-deploy disk <span class="built_in">list</span> ceph-node3</span><br></pre></td></tr></table></figure></p><p>创建osd<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy <span class="params">--overwrite-conf</span> osd create ceph-node1 <span class="params">--data</span> <span class="string">/dev/vdb</span> </span><br><span class="line">ceph-deploy <span class="params">--overwrite-conf</span> osd create ceph-node2 <span class="params">--data</span> <span class="string">/dev/vdb</span> </span><br><span class="line">ceph-deploy <span class="params">--overwrite-conf</span> osd create ceph-node3 <span class="params">--data</span> <span class="string">/dev/vdb</span></span><br></pre></td></tr></table></figure></p><p>创建 ceph mgr 管理进程服务，自12版本启用<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy <span class="comment">--overwrite-conf mgr create ceph-node1</span></span><br><span class="line">ceph-deploy <span class="comment">--overwrite-conf mgr create ceph-node2</span></span><br><span class="line">ceph-deploy <span class="comment">--overwrite-conf mgr create ceph-node3</span></span><br></pre></td></tr></table></figure></p><p>创建mon<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy <span class="comment">--overwrite-conf mon create ceph-node1</span></span><br><span class="line">ceph-deploy <span class="comment">--overwrite-conf admin ceph-node1</span></span><br><span class="line">ceph-deploy <span class="comment">--overwrite-conf mon create ceph-node2</span></span><br><span class="line">ceph-deploy <span class="comment">--overwrite-conf admin ceph-node2</span></span><br><span class="line">ceph-deploy <span class="comment">--overwrite-conf mon create ceph-node3</span></span><br><span class="line">ceph-deploy <span class="comment">--overwrite-conf admin ceph-node3</span></span><br></pre></td></tr></table></figure></p><p>取消Cephx认证（可选）<br>把下列配置加入 Ceph 配置文件的 [global] 段下即可禁用 cephx 认证<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auth cluster required = none</span><br><span class="line">auth<span class="built_in"> service </span>required = none</span><br><span class="line">auth<span class="built_in"> client </span>required = none</span><br></pre></td></tr></table></figure></p><p>修改后，需要重启 Ceph服务，在每个ceph节点上都需要执行<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart ceph-mon.<span class="keyword">target</span></span><br><span class="line">systemctl restart ceph-osd.<span class="keyword">target</span></span><br></pre></td></tr></table></figure></p><p>启用dashboard (在mon节点)<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph mgr <span class="class"><span class="keyword">module</span> <span class="title">enable</span> <span class="title">dashboard</span></span></span><br></pre></td></tr></table></figure></p><p>设置dashboard的ip和端口<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph <span class="built_in">config</span>-key <span class="built_in">put</span> mgr/dashboard/server_addr ceph-node1</span><br><span class="line">ceph <span class="built_in">config</span>-key <span class="built_in">put</span> mgr/dashboard/server_port <span class="number">8443</span></span><br><span class="line">systemctl restart ceph-mgr@ceph-node1</span><br></pre></td></tr></table></figure></p><p>生成并安装自签名证书<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph dashboard <span class="keyword">create</span>-<span class="keyword">self</span>-signed-cert</span><br><span class="line"><span class="keyword">Self</span>-signed certificate created</span><br></pre></td></tr></table></figure></p><p>创建具有管理员角色的用户<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph dashboard <span class="keyword">set</span>-login-credentials <span class="comment">admin admin</span></span><br><span class="line">Username <span class="comment">and password updated</span></span><br></pre></td></tr></table></figure></p><p>登录Web界面<br><img src="/images/ceph-dashboard.png" alt="image"></p><h2 id="制作repo文件"><a href="#制作repo文件" class="headerlink" title="制作repo文件"></a>制作repo文件</h2><p>拷贝安装下载的ceph rpm包到指定文件夹<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find <span class="meta-keyword">/var/</span>cache<span class="meta-keyword">/yum/</span> -name *.rpm | xargs -i <span class="class">cp </span>&#123;&#125; ceph_mimic_rpms/</span><br></pre></td></tr></table></figure></p><p>这里要用到createrepo命令，如果没有此命令需要先安装它<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> createrepo -y</span><br></pre></td></tr></table></figure></p><p>生成一个repodata文件夹<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">createrepo</span> ceph_mimic_rpms/</span><br></pre></td></tr></table></figure></p><p>之后就可以正常离线安装ceph。如果机器无法访问外网，需要事先从<a href="https://download.ceph.com/keys/release.asc" target="_blank" rel="noopener">https://download.ceph.com/keys/release.asc</a> 下载对应的release.asc文件，上传到集群的每一个节点上，执行如下命令：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --<span class="keyword">import</span> <span class="string">'./release.asc'</span></span><br></pre></td></tr></table></figure></p><p>rpm包更新<br>在使用过程中，可能还需要添加其他rpm包，把rpm包丢到ceph_mimic_rpms/目录下，我们不用重新制作repodata文件，只需要update一下。<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createrepo <span class="comment">--update ceph_mimic_rpms/</span></span><br></pre></td></tr></table></figure></p><h2 id="本机使用ceph离线源"><a href="#本机使用ceph离线源" class="headerlink" title="本机使用ceph离线源"></a>本机使用ceph离线源</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir  /etc/yum<span class="selector-class">.repos</span><span class="selector-class">.d</span>/backup</span><br><span class="line">mv /etc/yum<span class="selector-class">.repos</span><span class="selector-class">.d</span><span class="comment">/*.repo  /etc/yum.repos.d/backup</span></span><br></pre></td></tr></table></figure><p>在文件 /etc/yum.repos.d/ceph-deploy.repo中添加以下内容，保存<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[LocalCeph]</span></span><br><span class="line"><span class="attr">name</span>=LocalCeph</span><br><span class="line"><span class="attr">baseurl</span>=file:///opt/ceph_mimic_rpms    //ceph包存放目录</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>执行下面命令生效<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum clean <span class="keyword">all</span></span><br><span class="line">yum makecache</span><br><span class="line">yum <span class="keyword">list</span> | <span class="keyword">grep</span> ceph</span><br></pre></td></tr></table></figure></p><p>最后，离线安装ceph，过程同上。</p><h2 id="其他机器使用ceph离线源"><a href="#其他机器使用ceph离线源" class="headerlink" title="其他机器使用ceph离线源"></a>其他机器使用ceph离线源</h2><p>在ceph源机器上安装nginx，createrepo，reposync<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> nginx createrepo yum-utils -y</span><br></pre></td></tr></table></figure></p><p>在nginx根目录建立文件夹<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="regexp">/usr/</span>share<span class="regexp">/nginx/</span>html<span class="regexp">/yum/</span>x86_64<span class="regexp">/ceph/</span>RPMS</span><br></pre></td></tr></table></figure></p><p>启动nginx<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="builtin-name">enable</span> nginx &amp;&amp; systemctl restart nginx</span><br></pre></td></tr></table></figure></p><p>将下载的ceph包放在/usr/share/nginx/html/yum/x86_64/ceph/RPMS目录下</p><p>自动生成repodata<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createrepo -p <span class="regexp">/usr/</span>share<span class="regexp">/nginx/</span>html<span class="regexp">/yum/</span>x86_64<span class="regexp">/ceph/</span></span><br></pre></td></tr></table></figure></p><p>在client端创建repo文件ceph-deploy.repo<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Ceph]</span></span><br><span class="line"><span class="attr">name</span>=Ceph</span><br><span class="line"><span class="attr">baseurl</span>=http://server IP/yum/x<span class="number">86_64</span>/ceph</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>验证<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum clean <span class="keyword">all</span></span><br><span class="line">yum makecache</span><br><span class="line">yum <span class="keyword">list</span> | <span class="keyword">grep</span> ceph</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;p&gt;系统：Centos 7（系统最小化安装）&lt;br&gt;版本：Ceph mimic&lt;/p&gt;
&lt;h2 id=&quot;系统配置&quot;&gt;&lt;a href=&quot;#系统配置
      
    
    </summary>
    
      <category term="Ceph" scheme="http://yoursite.com/categories/Ceph/"/>
    
    
      <category term="Ceph" scheme="http://yoursite.com/tags/Ceph/"/>
    
  </entry>
  
  <entry>
    <title>使用cert-manager实现Ingress https</title>
    <link href="http://yoursite.com/2019/03/14/%E4%BD%BF%E7%94%A8cert-manager%E5%AE%9E%E7%8E%B0Ingress-https/"/>
    <id>http://yoursite.com/2019/03/14/使用cert-manager实现Ingress-https/</id>
    <published>2019-03-14T11:21:36.000Z</published>
    <updated>2019-03-16T12:47:33.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是https"><a href="#什么是https" class="headerlink" title="什么是https"></a>什么是https</h2><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><h2 id="什么是cert-manager"><a href="#什么是cert-manager" class="headerlink" title="什么是cert-manager"></a>什么是cert-manager</h2><p>cert-manager 是一个云原生证书管理开源项目，用于在 Kubernetes 集群中提供 HTTPS 证书并自动续期，支持 Let’s Encrypt, HashiCorp Vault 这些免费证书的签发。在Kubernetes集群中，我们可以通过 Kubernetes Ingress 和 Let’s Encrypt 实现外部服务的自动化 HTTPS。</p><p>在Kubernetes集群中使用 HTTPS 协议，需要一个证书管理器、一个证书自动签发服务，主要通过 Ingress 来发布 HTTPS 服务，因此需要Ingress Controller并进行配置，启用 HTTPS 及其路由。<br><img src="/images/cert-manager.png" alt="image"></p><p><strong>环境依赖</strong></p><ul><li>本文使用 Helm 安装，所以请确保 Helm 已安装，且版本最好&gt;2.10</li><li>集群必须已经装有 Ingress Controller</li><li>外部客户端配置hosts，IP 指向 Ingress Controller 对外暴露的地址（如果IP是公网地址并做了域名解析，则无需配置）</li></ul><h2 id="部署cert-manager"><a href="#部署cert-manager" class="headerlink" title="部署cert-manager"></a>部署cert-manager</h2><h3 id="使用helm安装cert-manager"><a href="#使用helm安装cert-manager" class="headerlink" title="使用helm安装cert-manager"></a>使用helm安装cert-manager</h3><p>安装 CustomResourceDefinition资源<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/jetstack/</span>cert-manager<span class="regexp">/release-0.7/</span>deploy<span class="regexp">/manifests/</span><span class="number">00</span>-crds.yaml</span><br></pre></td></tr></table></figure></p><p>创建cert-manager namespace<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">create</span> <span class="keyword">namespace</span> cert-manager</span><br></pre></td></tr></table></figure></p><p>标记cert-Manager命名空间以禁用资源验证<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="selector-tag">label</span> namespace cert-manager certmanager<span class="selector-class">.k8s</span><span class="selector-class">.io</span>/disable-validation=true</span><br></pre></td></tr></table></figure></p><p>添加 Jetstack Helm repository<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm repo <span class="keyword">add</span> jetstack https:<span class="comment">//charts.jetstack.io</span></span><br></pre></td></tr></table></figure></p><p>更新本地Helm chart repository<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">helm repo update</span></span><br></pre></td></tr></table></figure></p><p>使用Helm chart安装cert-manager<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">helm install \</span><br><span class="line">  -<span class="ruby">-name cert-manager \</span></span><br><span class="line"><span class="ruby">  --namespace cert-manager \</span></span><br><span class="line"><span class="ruby">  --version v<span class="number">0</span>.<span class="number">7.0</span> \</span></span><br><span class="line"><span class="ruby">  jetstack/cert-manager</span></span><br></pre></td></tr></table></figure></p><p>查看cert-manager部署结果<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get pods --namespace cert-manager</span><br><span class="line">NAME                                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">cert-manager<span class="number">-5658</span>b7db79<span class="number">-824</span>lt              <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">11</span>h</span><br><span class="line">cert-manager-cainjector<span class="number">-768</span>fd47f68-ls6zh   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">11</span>h</span><br><span class="line">cert-manager-webhook<span class="number">-5</span>b4bc6b547<span class="number">-8</span>qk2v      <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">11</span>h</span><br></pre></td></tr></table></figure></p><h3 id="创建ClusterIssuer"><a href="#创建ClusterIssuer" class="headerlink" title="创建ClusterIssuer"></a>创建ClusterIssuer</h3><p>我们需要先创建一个签发机构，cert-manager 给我们提供了 Issuer 和 ClusterIssuer 这两种用于创建签发机构的自定义资源对象，Issuer 只能用来签发自己所在 namespace 下的证书，ClusterIssuer 可以签发任意 namespace 下的证书，这里以 ClusterIssuer 为例创建一个签发机构：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># cat issuer.yaml </span></span><br><span class="line"><span class="symbol">apiVersion:</span> certmanager.k8s.io/v1alpha1</span><br><span class="line"><span class="symbol">kind:</span> ClusterIssuer</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  name:</span> letsencrypt-prod</span><br><span class="line"><span class="symbol">spec:</span></span><br><span class="line"><span class="symbol">  acme:</span></span><br><span class="line"><span class="symbol">    server:</span> https:<span class="comment">//acme-v02.api.letsencrypt.org/directory</span></span><br><span class="line"><span class="symbol">    email:</span> xxxx@<span class="number">126.</span>com</span><br><span class="line"><span class="symbol">    privateKeySecretRef:</span></span><br><span class="line"><span class="symbol">      name:</span> letsencrypt-prod</span><br><span class="line"><span class="symbol">    http01:</span> &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li>metadata.name 是我们创建的签发机构的名称，后面我们创建证书的时候会引用它</li><li>spec.acme.email 是你自己的邮箱，证书快过期的时候会有邮件提醒，不过 cert-manager 会利用 acme 协议自动给我们重新颁发证书来续期</li><li>spec.acme.server 是 acme 协议的服务端，我们这里用 Let’s Encrypt，这个地址就写死成这样就行</li><li>spec.acme.privateKeySecretRef 指示此签发机构的私钥将要存储到哪个 Secret 对象中，名称不重要</li><li>spec.acme.http01 这里指示签发机构使用 HTTP-01 的方式进行 acme 协议 (还可以用 DNS 方式，acme 协议的目的是证明这台机器和域名都是属于你的，然后才准许给你颁发证书)</li></ul><p>部署<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f issuer.yaml</span></span><br></pre></td></tr></table></figure></p><p>查看clusterissuer创建结果<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl get clusterissuer</span></span><br><span class="line"><span class="attribute">NAME</span>               AGE</span><br><span class="line">letsencrypt-prod   <span class="number">11m</span></span><br></pre></td></tr></table></figure></p><h3 id="创建Certificate"><a href="#创建Certificate" class="headerlink" title="创建Certificate"></a>创建Certificate</h3><p>有了签发机构，接下来我们就可以生成免费证书了，cert-manager 给我们提供了 Certificate 这个用于生成证书的自定义资源对象，它必须局限在某一个 namespace 下，证书最终会在这个 namespace 下以 Secret 的资源对象存储，创建一个 Certificate 对象：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat cert.yaml </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">certmanager.k8s.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Certificate</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">dashboard-imroc-io</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  secretName:</span> <span class="string">dashboard-imroc-io</span></span><br><span class="line"><span class="attr">  issuerRef:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">letsencrypt-prod</span></span><br><span class="line"><span class="attr">    kind:</span> <span class="string">ClusterIssuer</span></span><br><span class="line"><span class="attr">  dnsNames:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">istio.kiali.com</span></span><br><span class="line"><span class="attr">  acme:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">    - http01:</span></span><br><span class="line"><span class="attr">        ingressClass:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">      domains:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">istio.kiali.com</span></span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li>spec.secretName 指示证书最终存到哪个 Secret 中</li><li>spec.issuerRef.kind 值为 ClusterIssuer 说明签发机构不在本 namespace 下，而是在全局</li><li>spec.issuerRef.name 我们创建的签发机构的名称 (ClusterIssuer.metadata.name)</li><li>spec.dnsNames 指示该证书的可以用于哪些域名</li><li>spec.acme.config.http01.ingressClass 使用 HTTP-01 方式校验该域名和机器时，cert-manager 会尝试创建Ingress 对象来实现该校验，如果指定该值，会给创建的 Ingress 加上 kubernetes.io/ingress.class 这个 annotation，如果我们的 Ingress Controller 是 traefik Ingress Controller，指定这个字段可以让创建的 Ingress 被 traefik Ingress Controller 处理。</li><li>spec.acme.config.http01.domains 指示该证书的可以用于哪些域名</li></ul><p>执行部署命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f cert.yaml</span></span><br></pre></td></tr></table></figure></p><p>查看certificate创建结果<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get certificate -n istio-<span class="keyword">system</span></span><br><span class="line">NAME                 AGE</span><br><span class="line">dashboard-imroc-io   <span class="number">54</span>s</span><br></pre></td></tr></table></figure></p><p>执行上述步骤，如有问题，可使用如下命令排查原因<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl describe -n istio-system certificate dashboard-imroc-io</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl describe clusterissuer letsencrypt-prod</span></span><br></pre></td></tr></table></figure></p><p>查看生成的secret 结果<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get secret -n istio-system | grep dashboard-imroc-<span class="built_in">io</span></span><br><span class="line">dashboard-imroc-<span class="built_in">io</span>                              kubernetes.<span class="built_in">io</span>/tls                     <span class="number">3</span>      <span class="number">2</span>m32s</span><br></pre></td></tr></table></figure></p><h2 id="测试Ingress使用https"><a href="#测试Ingress使用https" class="headerlink" title="测试Ingress使用https"></a>测试Ingress使用https</h2><p>创建一个nginx<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat test-nginx.yaml </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">443</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    run:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubernetes.io/ingress.class:</span> <span class="string">"traefik"</span></span><br><span class="line">    <span class="string">kubernetes.io/tls-acme:</span> <span class="string">"true"</span></span><br><span class="line"><span class="string">certmanager.k8s.io/cluster-issuer:</span> <span class="string">"letsencrypt-prod"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">test.nginx.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">  tls:</span></span><br><span class="line"><span class="attr">  - secretName:</span> <span class="string">dashboard-imroc-io</span></span><br><span class="line"><span class="attr">    hosts:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">test.nginx.com</span></span><br></pre></td></tr></table></figure></p><p>需要注意的是上面我们添加的两个annotations非常重要，这个将告诉 Cert Manager 去生成证书，然后由于我们这里要使用 HTTPS，所以我们需要添加一个 tls 证书，而证书就是通过k8sui-tls这个 Secret 对象来提供的，要注意的是这个 Secret 对象并不是我们手动创建的，而是 Cert Manager 自动创建的证书对应的对应。然后直接创建这个资源对象即可：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f <span class="built_in">test</span>-nginx.yaml</span></span><br></pre></td></tr></table></figure></p><p>创建完成后隔一会儿我们可以看到会多出现一个随机名称的 Ingress 对象，这个 Ingress 对象就是用来专门验证证书的：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl get ingress -n istio-system</span></span><br><span class="line">NAME                        HOSTS                   <span class="built_in"> ADDRESS </span>  PORTS     AGE</span><br><span class="line">cm-acme-http-solver-z562f   test.nginx.com                     80        62s</span><br></pre></td></tr></table></figure></p><p>我们可以通过 Traefik 的 Dashboard 可以观察到这一变化，验证成功后，这个 Ingress 对象也自动删除了：</p><p>这个时候我们可以去describe下我们的 Ingress 对象，查看有无报错<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl describe ingress my-nginx</span></span><br></pre></td></tr></table></figure></p><p>同样我们可以去查看 Cert manager 的 Pod 日志信息：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kubectl logs -f cert-manager<span class="number">-5658</span>b7db79<span class="number">-824</span>lt --namespace cert-manager</span><br></pre></td></tr></table></figure></p><p>最后，我们来打开浏览器使用https访问服务</p><p>到这里我们就完成了使用Let’s Encrypt实现Kubernetes Ingress自动化 HTTPS。</p><p><strong>参考资料</strong><br>项目地址：<a href="https://github.com/jetstack/cert-manager" target="_blank" rel="noopener">https://github.com/jetstack/cert-manager</a><br>文档地址：<a href="https://cert-manager.readthedocs.io" target="_blank" rel="noopener">https://cert-manager.readthedocs.io</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是https&quot;&gt;&lt;a href=&quot;#什么是https&quot; class=&quot;headerlink&quot; title=&quot;什么是https&quot;&gt;&lt;/a&gt;什么是https&lt;/h2&gt;&lt;p&gt;超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方
      
    
    </summary>
    
      <category term="Kubernetes" scheme="http://yoursite.com/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="http://yoursite.com/tags/Kubernetes/"/>
    
      <category term="cert-manager" scheme="http://yoursite.com/tags/cert-manager/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Kubernetes生产架构</title>
    <link href="http://yoursite.com/2019/03/02/%E6%B5%85%E8%B0%88Kubernetes%E7%94%9F%E4%BA%A7%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2019/03/02/浅谈Kubernetes生产架构/</id>
    <published>2019-03-02T12:55:43.000Z</published>
    <updated>2019-06-16T08:49:38.104Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注意</strong><br>本文，只是笔者针对Kubernetes生产环境运行的一些关于架构设计和实现方案的总结，内容很粗糙，同时也会不断完善。</p><p>首先，我们来梳理下Kubernetes生产环境一个粗略的业务架构，如下图所示。<br><img src="/images/k8s-jiagou.png" alt="image"></p><p>在该架构中，我们可以将其分为四层，如下：</p><ul><li>Client层：即Kubernetes集群外部用户、客户端等；</li><li>服务访问层：即由Traefik ingress实现服务发现、负载均衡和路由规则定义等；</li><li>业务应用层：即基于Kubernetes平台构建和运行企业业务应用，如CI/CD持续集成、微服务项目、监控告警和日志管理、私有镜像仓库等服务；</li><li>基础设施层：即由Kubernetes容器管理平台和Ceph数据持久化存储等系统组成的基础设施服务。</li></ul><p>下面，我们分别来谈谈各层的具体实现方案。</p><h2 id="基础设施层"><a href="#基础设施层" class="headerlink" title="基础设施层"></a>基础设施层</h2><p><strong>Kubernetes平台</strong></p><ul><li>部署管理：Kubernetes平台除了直接使用公有云如阿里云、AWS等云服务提供商的K8s服务外，我们还可以自己部署和管理等，如使用Kubespray工具。</li><li>网络通信：在容器和容器之间、容器和主机网络方面，可以使用Calico或Flannel等方案。</li><li>HA高可用：Kubernetes节点分为Master和Node两种类型节点，前者负责运行集群相关的控制管理服务，而后者负责运行Pod容器。在多Node节点模式下，由于Kubernetes Pod具有天然的容灾冗余HA高可用实现，因此，我们并不需要关心Node节点的HA高可用，而只需关心Master节点的HA即可，Master节点的HA高可用，通过多Master节点+HAProxy方案实现即可。从Kubernetes 1.12版本起，kube-proxy服务默认使用ipvs实现，取消了之前的iptables。这有助于提升K8s大规模集群环境下的性能和稳定性。</li><li>Docker和操作系统优化：在生产环境中，Docker和操作系统版本应当使用较新的release版本。并且，主机操作系统应当做一定程度的优化配置，如关闭swap内存交换分区，预留一定的CPU核数和内存资源给宿主机使用等。</li></ul><p><strong>Ceph/NFS数据存储</strong><br>Kubernetes平台的数据持久化存储，可以使用Ceph、NFS等存储方案。其中，Ceph适用于有其技术背景或大容量存储需求的公司；而NFS适用于存储容量需求相对较小，无专业存储技术背景的公司。</p><h2 id="业务应用层"><a href="#业务应用层" class="headerlink" title="业务应用层"></a>业务应用层</h2><ul><li>镜像管理：使用Harbor私有镜像仓库服务；</li><li>日志管理：使用Elasticsearch、Filebeat 和 Kibana技术栈；</li><li>监控告警管理：使用Cadvisor、Prometheus和Grafana技术栈；</li><li>微服务架构：使用Service Mesh服务网格中的Istio方案；</li><li>Devops：使用Gitlab、Jenkins等持续集成工具；</li><li>单体应用：无状态类服务使用deployment，有状态类服务则使用Statefulset，如果关联的服务较多且复杂则使用Helm。</li><li>规划好Namespace：应当做到每个namespace专属用于某类型的应用，如monitor namespace统一管理诸如监控告警和日志管理方面的pod、service、pvc、ingress等资源。这样，可以较为方便的管理和区分K8s上的各种应用。</li></ul><h2 id="服务访问层"><a href="#服务访问层" class="headerlink" title="服务访问层"></a>服务访问层</h2><p>外部客户端访问K8s集群内的服务、负载均衡和路由规则定义使用Traefik Ingress实现。此外，应当实现Ingress服务HA高可用，可以想象在K8s集群中，大量的出入口流量都进过Ingress，其负载是非常大的，其重要程度不言而喻，因此实现HA就非常重要。ingress controller节点（无论是基于nginx还是traefik实现）应当至少为2个节点，并在这些节点上，部署Keepalived和HAproxy共同维护一个VIP地址，将其提供给ingress使用。</p><p>架构如下图所示。<br><img src="/images/ingress-ha.png" alt="image"></p><p>在该架构中，Ingress节点一般使用独立的服务器部署在K8s平台的边缘节点，即只做将集群外部流量接入到集群内部。除了使用external Ip来暴露ingress的Service到集群外部，还可以使用hostNetwork，如果是公有云，还可以使用LoadBalance。这样Ingress Controller将监听节点的80和443端口。</p><p>如上图所示，当外部客户端访问域名”<a href="http://www.taobao.com“时（举例而已，切勿当真），首先经过LVS/F5第一层负载均衡，然后经由两个Traefik" target="_blank" rel="noopener">www.taobao.com“时（举例而已，切勿当真），首先经过LVS/F5第一层负载均衡，然后经由两个Traefik</a> Ingress集群做第二层负载分发（每个集群由2个节点实现主备HA高可用），其次客户端流量请求转发到第三层负载均衡Service，最后转发到后端对应的Pod。K8s平台和后端业务平台均是内网环境，通过第一层负载均衡的公网IP进行转发或映射，实现内外网通信和安全隔离。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;br&gt;本文，只是笔者针对Kubernetes生产环境运行的一些关于架构设计和实现方案的总结，内容很粗糙，同时也会不断完善。&lt;/p&gt;
&lt;p&gt;首先，我们来梳理下Kubernetes生产环境一个粗略的业务架构，如下图所示。&lt;br&gt;&lt;img 
      
    
    </summary>
    
      <category term="Kubernetes" scheme="http://yoursite.com/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="http://yoursite.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes Istio微服务架构部署和使用</title>
    <link href="http://yoursite.com/2019/03/01/Kubernetes-Istio%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E9%83%A8%E7%BD%B2%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/03/01/Kubernetes-Istio微服务架构部署和使用/</id>
    <published>2019-03-01T13:55:02.000Z</published>
    <updated>2019-05-14T14:20:10.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Istio"><a href="#什么是Istio" class="headerlink" title="什么是Istio"></a>什么是Istio</h2><p>Istio是Service Mesh（服务网格）的主流实现方案。该方案降低了与微服务架构相关的复杂性，并提供了负载均衡、服务发现、流量管理、断路器、监控、故障注入和智能路由等功能特性。</p><p>其中，Sidecar模式是一种将应用功能从应用本身剥离出来作为单独进程的方式。该模式允许我们向应用无侵入添加多种功能，避免了为满足第三方组件需求而向应用添加额外的配置代码。从某种意义上来说，服务对于网络是无感知的，只知道所附加的sidecar代理，它将网络依赖抽象成了Sidecar。</p><p><strong>在Service Mesh中，我们需要了解Data Plane和Control Plane两个概念：</strong></p><ul><li>Data Plane：作用是处理网格内服务间的通信，并完成服务发现、负载均衡、流量管理、健康检查等功能；</li><li>Control Plane：作用是管理和配置智能代理用于路由流量，同时配置Mixers来应用策略、收集指标。</li></ul><p><strong>Istio核心组件</strong></p><ul><li>Envoy：Istio 使用 Envoy调解服务网格中所有服务的入站和出站流量。属于数据平面。</li><li>Mixer：负责在服务网格上执行访问控制和使用策略，以及收集从Envoy和其他服务自动监控到的数据。</li><li>Pilot：为 Envoy sidecar 提供服务发现功能，为智能路由（例如 A/B 测试、金丝雀部署等）和弹性（超时、重试、熔断器等）提供流量管理功能。属于控制平面。</li><li>Citadel：提供访问控制和用户身份认证功能。</li></ul><p><strong>Istio可视化管理组件</strong></p><ul><li><p>Vistio：用于近乎实时地监控应用程序和集群之间的网络流量。<br>可以参考：<a href="https://www.yangcs.net/posts/vistio-visualize-your-istio-mesh-using-netflixs-vizceral/" target="_blank" rel="noopener">https://www.yangcs.net/posts/vistio-visualize-your-istio-mesh-using-netflixs-vizceral/</a></p></li><li><p>Kiali：提供可视化服务网格拓扑、断路器和请求率等功能。Kiali还包括 Jaeger Tracing，可以提供开箱即用的分布式跟踪功能。<br>可以参考：<a href="https://jimmysong.io/istio-handbook/setup/istio-observability-tool-kiali.html" target="_blank" rel="noopener">https://jimmysong.io/istio-handbook/setup/istio-observability-tool-kiali.html</a></p></li><li><p>jaeger：用于展示istio微服务调用链关系，以及微服务工作状态监测。注意，在生产环境中，你应当使用Elasticsearch或cassandra持久化存储jaeger数据。<br>可以参考：<a href="https://blog.csdn.net/ywq935/article/details/80599297" target="_blank" rel="noopener">https://blog.csdn.net/ywq935/article/details/80599297</a><br><a href="https://mathspanda.github.io/2018/09/19/jaeger-deploy/" target="_blank" rel="noopener">https://mathspanda.github.io/2018/09/19/jaeger-deploy/</a><br><a href="https://blog.frognew.com/2017/12/opentracing-jaeger-3.html" target="_blank" rel="noopener">https://blog.frognew.com/2017/12/opentracing-jaeger-3.html</a></p></li></ul><p>其中，Kiali、Jaeger、prometheus、grafana管理工具，将和Istio一并部署。</p><h2 id="使用Helm部署Istio"><a href="#使用Helm部署Istio" class="headerlink" title="使用Helm部署Istio"></a>使用Helm部署Istio</h2><p><strong>依赖环境</strong><br>Helm &gt; 2.10<br>Kubernetes &gt; 1.9</p><p>下载并解压缩istio的发布包<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="regexp">//gi</span>thub.com<span class="regexp">/istio/i</span>stio<span class="regexp">/releases/</span>download<span class="regexp">/1.0.6/i</span>stio-<span class="number">1.0</span>.<span class="number">6</span>-linux.tar.gz</span><br><span class="line">tar -zxvf istio-<span class="number">1.0</span>.<span class="number">6</span>-linux.tar.gz</span><br><span class="line">cd istio-<span class="number">1.0</span>.<span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>Istio的Chart在istio-1.0.6/install/kubernetes/helm目录中，这个Chart包含了下面的代码文件<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># tree install/kubernetes/helm/istio</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="number">31</span> directories, <span class="number">139</span> files</span><br></pre></td></tr></table></figure></p><p>如果安装的Helm版本高于2.10，就不再需要手动使用kubectl安装Istio的CRD。反之，则需要执行如下命令安装<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f install<span class="regexp">/kubernetes/</span>helm<span class="regexp">/istio/</span>templates<span class="regexp">/crds.yaml</span></span><br></pre></td></tr></table></figure></p><p>查看安装的CRD<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="builtin-name">get</span> CustomResourceDefinition</span><br></pre></td></tr></table></figure></p><p>通过各个组件在vaule file的enabled flag启用或禁用，下面创建名称为istio.yaml的vaule file，将几个默认禁用的组件也启用<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tracing:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">servicegraph:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">kiali:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">grafana:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>首先，创建名称为kiali的secret。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> -n <span class="string">'admin'</span> | base64</span></span><br><span class="line">YWRtaW4=</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> -n <span class="string">'1f2d1e2e67df'</span> | base64</span></span><br><span class="line">MWYyZDFlMmU2N2Rm</span><br></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># cat &lt;&lt;EOF | kubectl apply -f -</span></span><br><span class="line"><span class="symbol">apiVersion:</span> v1</span><br><span class="line"><span class="symbol">kind:</span> Secret</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  name:</span> kiali</span><br><span class="line"><span class="symbol">  namespace:</span> istio-system</span><br><span class="line"><span class="symbol">  labels:</span></span><br><span class="line"><span class="symbol">    app:</span> kiali</span><br><span class="line"><span class="symbol">type:</span> Opaque</span><br><span class="line"><span class="symbol">data:</span></span><br><span class="line"><span class="symbol">  username:</span> YWRtaW4=</span><br><span class="line"><span class="symbol">  passphrase:</span> MWYyZDFlMmU2N2Rm</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>执行helm安装命令<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm <span class="keyword">install</span> <span class="keyword">install</span>/kubernetes/helm/istio <span class="comment">--name istio --namespace istio-system -f istio.yaml</span></span><br></pre></td></tr></table></figure></p><p>安装完成后确认各个组件的Pod正常运行<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get pod -n istio-system</span><br><span class="line">NAME                                      READY   STATUS      RESTARTS   AGE</span><br><span class="line">grafana<span class="number">-59</span>b8896965<span class="number">-5</span>f9j2                  <span class="number">1</span>/<span class="number">1</span>     Running     <span class="number">0</span>          <span class="number">23</span>m</span><br><span class="line">istio-citadel<span class="number">-6</span>f444d9999-s9jrc            <span class="number">1</span>/<span class="number">1</span>     Running     <span class="number">0</span>          <span class="number">23</span>m</span><br><span class="line">istio-egressgateway<span class="number">-6</span>d79447874-ssbc4      <span class="number">1</span>/<span class="number">1</span>     Running     <span class="number">0</span>          <span class="number">23</span>m</span><br><span class="line">istio-galley<span class="number">-685</span>bb48846-mvf5w             <span class="number">1</span>/<span class="number">1</span>     Running     <span class="number">0</span>          <span class="number">23</span>m</span><br><span class="line">istio-grafana-post-install<span class="number">-6</span>m256          <span class="number">0</span>/<span class="number">1</span>     Completed   <span class="number">0</span>          <span class="number">23</span>m</span><br><span class="line">istio-ingressgateway<span class="number">-5</span>b64fffc9f-mrl9t     <span class="number">1</span>/<span class="number">1</span>     Running     <span class="number">0</span>          <span class="number">23</span>m</span><br><span class="line">istio-pilot<span class="number">-8645</span>f5655b-k6fcz              <span class="number">2</span>/<span class="number">2</span>     Running     <span class="number">0</span>          <span class="number">23</span>m</span><br><span class="line">istio-policy<span class="number">-547</span>d64b8d7<span class="number">-6</span>dgkp             <span class="number">2</span>/<span class="number">2</span>     Running     <span class="number">0</span>          <span class="number">23</span>m</span><br><span class="line">istio-sidecar-injector<span class="number">-5</span>d8dd9448d-zfdsb   <span class="number">1</span>/<span class="number">1</span>     Running     <span class="number">0</span>          <span class="number">23</span>m</span><br><span class="line">istio-telemetry-c5488fc49-qwwcv           <span class="number">2</span>/<span class="number">2</span>     Running     <span class="number">0</span>          <span class="number">23</span>m</span><br><span class="line">istio-tracing<span class="number">-6</span>b994895fd<span class="number">-4</span>vjfx            <span class="number">1</span>/<span class="number">1</span>     Running     <span class="number">0</span>          <span class="number">23</span>m</span><br><span class="line">kiali<span class="number">-5</span>f9ffff7cf-jqk8p                    <span class="number">1</span>/<span class="number">1</span>     Running     <span class="number">0</span>          <span class="number">23</span>m</span><br><span class="line">prometheus<span class="number">-76</span>b7745b64-xjzmm               <span class="number">1</span>/<span class="number">1</span>     Running     <span class="number">0</span>          <span class="number">23</span>m</span><br><span class="line">servicegraph-cb9b94c-mlhjm                <span class="number">1</span>/<span class="number">1</span>     Running     <span class="number">0</span>          <span class="number">23</span>m</span><br></pre></td></tr></table></figure></p><p>Istio 以一个项目的形式部署到 Kubernetes 集群中。我们可以看到，部署好的 pods 中，除了有 istio-citadel、istio-egressgateway、istio-ingressgateway、istio-pilot 等 Istio 本身的功能组件，还集成了微服务相关的监控工具，如：grafana、jaeger-agent、kiali、prometheus。正是这些功能丰富且强大的监控工具，帮助 Istio实现了微服务的可视化管理。</p><h2 id="运行示例Bookinfo"><a href="#运行示例Bookinfo" class="headerlink" title="运行示例Bookinfo"></a>运行示例Bookinfo</h2><p>您可以部署自己的应用或者示例应用程序如 Bookinfo。 注意：应用程序必须使用 HTTP/1.1 或 HTTP/2.0 协议来传递 HTTP 流量，因为 HTTP/1.0 已经不再支持。</p><p>如果运行 Pod 的 namespace 被标记为 istio-injection=enabled 的话，Istio-Initializer 会向应用程序的 Pod 中自动注入 Envoy 容器：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl label <span class="keyword">namespace</span> &lt;<span class="keyword">namespace</span>&gt; istio-injection=enabled</span><br><span class="line">kubectl <span class="keyword">create</span> -n &lt;<span class="keyword">namespace</span>&gt; -f &lt;your-app-spec&gt;.yaml</span><br></pre></td></tr></table></figure></p><p>如果您没有安装 Istio-initializer-injector 的话，您必须使用 istioctl kube-inject 命令在部署应用之前向应用程序的 Pod 中手动注入 Envoy 容器：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f &lt;<span class="comment">(istioctl kube-inject -f &lt;your-app-spec&gt;.yaml)</span></span><br></pre></td></tr></table></figure></p><p>Bookinfo 应用由四个单独的微服务构成，用来演示多种 Istio 特性，包含：</p><ul><li>productpage ：productpage 微服务会调用 details 和 reviews 两个微服务，用来生成页面。</li><li>details ：这个微服务包含了书籍的信息。</li><li>reviews ：这个微服务包含了书籍相关的评论。它还会调用 ratings 微服务。</li><li>ratings ：ratings 微服务中包含了由书籍评价组成的评级信息。</li></ul><p>reviews 微服务有 3 个版本：</p><ul><li>v1 版本不会调用 ratings 服务。</li><li>v2 版本会调用 ratings 服务，并使用 1 到 5 个黑色星形图标来显示评分信息。</li><li>v3 版本会调用 ratings 服务，并使用 1 到 5 个红色星形图标来显示评分信息。</li></ul><p>下图展示了这个应用的端到端架构。<br><img src="/images/bookinfo-arch.png" alt="image"></p><p>运行示例bookinfo，并开启Sidecar自动注入。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl label namespace default istio-injection=enabled</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f samples/bookinfo/platform/consul/destination-rule-all.yaml</span></span><br></pre></td></tr></table></figure></p><p>访问productpage<br><a href="http://172.16.0.180:31380/productpage" target="_blank" rel="noopener">http://172.16.0.180:31380/productpage</a><br><img src="/images/bookinfo-istio.png" alt="image"></p><p>31380端口可以通过命令获取<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n istio-system <span class="builtin-name">get</span> svc istio-ingressgateway -o <span class="attribute">jsonpath</span>=<span class="string">'&#123;.spec.ports[0].nodePort&#125;'</span></span><br></pre></td></tr></table></figure></p><h2 id="使用Ingress暴露管理服务"><a href="#使用Ingress暴露管理服务" class="headerlink" title="使用Ingress暴露管理服务"></a>使用Ingress暴露管理服务</h2><p>完成Istio的安装后，可以看到安装的组件除了Istio架构中的数据平面和控制平面的各个核心组件，还部署了Prometheus、Grafana、Jaeger、Kiali等辅助组件。 在云原生生态中，我们已经对这些组件很熟悉了。</p><ul><li>Prometheus：监控系统，收集Istio的监控数据</li><li>Grafana：监控信息的图表展现，Istio部署的Grafana为我们内置了各个组件相关的Dashboard</li><li>Jaeger：分布式跟踪系统，Istio中集成Jaeger可以对基于Istio的微服务实现调用链跟踪、依赖分析，为性能优化和故障排查提供支持</li><li>kiali：kiali作为Istio的可视化管理工具，可以认为是Istio的UI，可以展现服务的网络拓扑、服务的容错情况(超时、重试、短路等)、分布式跟踪等</li></ul><p>这些辅助组件都有自己的web界面，这里我们使用ingress的方式将这些组件暴露到集群外，以便在集群外部访问。Istio支持使用自带的istio-ingressgateway将服务暴露到集群外部，这个和Kubernetes中暴露Ingress Controller类似，有很多种方式，如NodePort，LoadBalancer，或直接开启hostNetwork: true等等。为了便于统一管理K8s集群中的服务暴露，笔者更倾向使用Traefik Ingress。</p><p>使用Ingress暴露istio服务<br>编写ingress yaml文件，如下<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat istio-ingress.yaml </span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">jaeger-query</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">istio.jaeger-query.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">jaeger-query</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">16686</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">istio.prometheus.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">9090</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">grafana</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">istio.grafana.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">grafana</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiali</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">istio.kiali.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">kiali</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">20001</span></span><br></pre></td></tr></table></figure></p><p>执行部署命令<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">apply</span> -f istio-ingress.yaml</span><br></pre></td></tr></table></figure></p><p>外部客户端，配置hosts地址解析，如下<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">172<span class="selector-class">.16</span><span class="selector-class">.0</span><span class="selector-class">.180</span> <span class="selector-tag">istio</span><span class="selector-class">.prometheus</span><span class="selector-class">.com</span></span><br><span class="line">172<span class="selector-class">.16</span><span class="selector-class">.0</span><span class="selector-class">.180</span>  <span class="selector-tag">istio</span><span class="selector-class">.jaeger-query</span><span class="selector-class">.com</span></span><br><span class="line">172<span class="selector-class">.16</span><span class="selector-class">.0</span><span class="selector-class">.180</span>  <span class="selector-tag">istio</span><span class="selector-class">.grafana</span><span class="selector-class">.com</span></span><br><span class="line">172<span class="selector-class">.16</span><span class="selector-class">.0</span><span class="selector-class">.180</span>  <span class="selector-tag">istio</span><span class="selector-class">.kiali</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure></p><p><strong>访问jaeger</strong><br>浏览器访问Jaeger之前可以多次刷新productpage页面以便产生访问请求等。选择productpage.default可以查看整个调用链。使用istio.jaeger-query.com域名访问，结果展示：<br><img src="/images/jaeger-istio.png" alt="image"></p><p><strong>访问kiali</strong><br>使用域名istio.kiali.com访问kiali页面。用户名admin，密码1f2d1e2e67df。<br><img src="/images/kiali-istio.png" alt="image"></p><p><strong>访问prometheus</strong><br>使用域名istio.prometheus.com访问prometheus页面。<br><img src="/images/prometheus-istio.png" alt="image"></p><p><strong>访问grafana</strong><br>使用域名istio.grafana.com访问prometheus页面。<br><img src="/images/grafana-istio.png" alt="image"></p><h2 id="Istio-对-Pod-和服务的要求"><a href="#Istio-对-Pod-和服务的要求" class="headerlink" title="Istio 对 Pod 和服务的要求"></a>Istio 对 Pod 和服务的要求</h2><p>要成为服务网格的一部分，Kubernetes 集群中的 Pod 和服务必须满足以下几个要求：</p><ul><li>需要给端口正确命名：服务端口必须进行命名。端口名称只允许是&lt;协议&gt;[-&lt;后缀&gt;-]模式；</li><li>Pod必须关联到 Kubernetes服务：如果一个 Pod 属于多个服务，这些服务不能再同一端口上使用不同协议，例如 HTTP 和 TCP。</li><li>Deployment应带有app以及version标签：每个 Deployment 都应该有一个有意义的 app 标签和一个用于标识 Deployment 版本的 version 标签。Istio 会用 app 和 version 标签来给监控指标数据加入上下文信息。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文实践了使用istio官方提供的helm chart在Kubernetes上部署Istio 1.0.6的过程，并使用traefik ingress将Istio集成的Prometheus、Grafana、Jaeger、Kiali等辅助组件暴露到集群外部，并对进入集群的流量进行管理。</p><p>在生产环境中，如果是基于公有云，如阿里云、AWS等运行Istio，建议Ingress的IP地址使用ELB地址；如果是自建的平台，则建议使用HAproxy+Keepalived提供的VIP地址，作为Ingress的IP地址，实现高可用。</p><p>如果Ingress服务，需要暴露在公网，应当使用CA认证机构颁发的证书https化（如使用cert-manager）。此外建议使用NFS、Ceph等方案实现Istio监控以及微服务应用的数据持久化存储。</p><p><strong>istio参考资料</strong><br><a href="https://istio.io/zh/docs/" target="_blank" rel="noopener">https://istio.io/zh/docs/</a><br><a href="https://jimmysong.io/istio-handbook/" target="_blank" rel="noopener">https://jimmysong.io/istio-handbook/</a><br><a href="http://www.servicemesher.com/" target="_blank" rel="noopener">http://www.servicemesher.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Istio&quot;&gt;&lt;a href=&quot;#什么是Istio&quot; class=&quot;headerlink&quot; title=&quot;什么是Istio&quot;&gt;&lt;/a&gt;什么是Istio&lt;/h2&gt;&lt;p&gt;Istio是Service Mesh（服务网格）的主流实现方案。该方案降低了与微服务架构相关
      
    
    </summary>
    
      <category term="Kubernetes" scheme="http://yoursite.com/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="http://yoursite.com/tags/Kubernetes/"/>
    
      <category term="Istio" scheme="http://yoursite.com/tags/Istio/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes traefik ingress使用</title>
    <link href="http://yoursite.com/2019/03/01/Kubernetes-traefik-ingress%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/03/01/Kubernetes-traefik-ingress使用/</id>
    <published>2019-03-01T12:33:08.000Z</published>
    <updated>2019-06-20T13:39:40.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Traefik介绍"><a href="#Traefik介绍" class="headerlink" title="Traefik介绍"></a>Traefik介绍</h2><p>简单的说，ingress就是从kubernetes集群外访问集群的入口，将用户的URL请求转发到不同的service上。Ingress相当于nginx、apache等负载均衡反向代理服务器，其中还包括规则定义，即URL的路由信息。</p><p>Traefik是一款开源的反向代理与负载均衡工具。它最大的优点是能够与常见的微服务系统直接整合，实现自动化动态配置。Traefik通过不断地跟 kubernetes API 打交道，实时的感知后端 service、pod 等变化，比如pod，service 增加与减少等；当得到这些变化信息后，Ingress自动更新配置并热重载 ，达到服务发现的作用。</p><p>traefik整体架构如下所示。<br><img src="/images/traefik-arch.png" alt="image"></p><p><strong>Traefik主要特性详解</strong></p><ul><li><p>自动熔断<br>在集群中，当某一个服务大量出现请求错误，或者请求响应时间过久，或者返回500+错误状态码时，我们希望可以主动剔除该服务，也就是不在将请求转发到该服务上，而这一个过程是自动完成，不需要人工执行。Traefik 通过配置很容易就能帮我们实现，Traefik 可以通过定义策略来主动熔断服务。</p><p>  NetworkErrorRatio() &gt; 0.5：监测服务错误率达到50%时，熔断。<br>  LatencyAtQuantileMS(50.0) &gt; 50：监测延时大于50ms时，熔断。<br>  ResponseCodeRatio(500, 600, 0, 600) &gt; 0.5：监测返回状态码为[500-600]在[0-600]区间占比超过50%时，熔断。</p></li><li><p>负载均衡策略<br>Traefik 提供两种负载均衡策略支持。一种是 wrr（加权轮训调度算法），一种是 drr（动态加权循环调度算法）。</p><p> wrr是默认的负载均衡策略，新创建的 service 权重都是一样为1，这样的话，请求会平均分给每个服务，但是这样很多时候会出现资源分配不均衡的问题，比如由于集群中每个机器配置不一样，而且服务消耗不一样，假设 A 资源使用率已经很高，而 B 属于空闲状态，如果还是均摊到每个服务的话，会加重 A 的负荷，这时候因该有一种策略能够主动识别并分担更多流量到 B 才对。</p><p> drr 就更加智能，它是一种动态加权轮训调度方式，它会记录一段时间内转发到 A 的请求数，跟转发到 B 的请求数对比，转发数量多，说明处理速度快，响应时间快。如果 A 处理请求速度比 B 快，那么就会调整 A 的权重，接下来的一段时间，就会转发更多请求给 A，相应的 B 的转发就少一些。整个过程都在不断的调整权重，实现请求的合理分配，从而达到资源使用最大化。 </p></li></ul><h2 id="部署Traefik-ingress"><a href="#部署Traefik-ingress" class="headerlink" title="部署Traefik ingress"></a>部署Traefik ingress</h2><p>创建ingress-rbac.yaml，将用于service account验证。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ingress</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ingress</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="attr">  - kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">ingress</span></span><br><span class="line"><span class="attr">    namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">  apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure></p><p>创建Depeloyment部署traefik，如文件名为deployment.yaml<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        k8s-app:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      terminationGracePeriodSeconds:</span> <span class="number">60</span></span><br><span class="line"><span class="attr">      hostNetwork:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">      serviceAccountName:</span> <span class="string">ingress</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - image:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">          limits:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">1000</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">3000</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">          requests:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">500</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">2000</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">          hostPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">8580</span></span><br><span class="line"><span class="attr">          hostPort:</span> <span class="number">8580</span></span><br><span class="line"><span class="attr">        args:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">--web</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">--web.address=:8580</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">--kubernetes</span></span><br></pre></td></tr></table></figure></p><p>注意我们这里用的是Deploy类型，没有限定该pod运行在哪个主机上。Traefik的端口是8580。</p><p>编写Traefik UI的ingress部署文件，如文件名为traefik-ui.yaml<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">traefik-web-ui</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8580</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">traefik-web-ui</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">traefik.ui.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">traefik-web-ui</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="string">web</span></span><br></pre></td></tr></table></figure></p><p>backend中要配置default namespace中启动的service名字。path就是URL地址后的路径，如traefik.frontend.io/path，service将会接受path这个路径，host最好使用service-name.filed1.filed2.domain-name这种类似主机名称的命名方式，方便区分服务。</p><p>配置完成后就可以启动treafik ingress了。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># kubectl <span class="built_in">create</span> -f .</span><br><span class="line">deployment.extensions/traefik-ingress-lb created</span><br><span class="line">serviceaccount/ingress created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.<span class="built_in">io</span>/ingress created</span><br><span class="line">service/traefik-web-ui created</span><br><span class="line">ingress.extensions/traefik-web-ui created</span><br><span class="line">ingress.extensions/traefik-ingress created</span><br></pre></td></tr></table></figure></p><p>查看是否部署成功<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl get pods -n kube-system | grep traefik</span></span><br><span class="line">traefik-ingress-lb-57786f6c44-cwr96        1/1     Running   0          2m27s</span><br><span class="line"></span><br><span class="line"><span class="comment"># kubectl get ingress -o wide --all-namespaces   </span></span><br><span class="line">NAMESPACE     NAME             HOSTS           <span class="built_in"> ADDRESS </span>  PORTS   AGE</span><br><span class="line">kube-system   traefik-web-ui   traefik.ui.com             80      12s</span><br></pre></td></tr></table></figure></p><p>在客户端配置hosts域名解析，如下<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">172<span class="selector-class">.16</span><span class="selector-class">.0</span><span class="selector-class">.180</span> <span class="selector-tag">traefik</span><span class="selector-class">.ui</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure></p><p>172.16.0.180是traefik pod所在的K8s节点，通过域名traefik.ui.com访问将可以看到dashboard。<br><img src="/images/traefik-ui.png" alt="image"></p><p>左侧黄色部分列出的是所有的rule，右侧绿色部分是所有的backend。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>下面模拟部署一个程序，以Nginx 为例，并使用drr动态轮训加权策略。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat nginx-deployment.yaml </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx-pod</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.15.5</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-service</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">traefik.ingress.kubernetes.io/load-balancer-method:</span> <span class="string">drr</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">nginx-service</span></span><br><span class="line"><span class="attr">        namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx-pod</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-ingress</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">k8s.nginx.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">nginx-service</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p><p>创建nginx<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">apply</span> -f nginx-deployment.yaml </span><br><span class="line">kubectl <span class="built_in">get</span> pods</span><br></pre></td></tr></table></figure></p><p>同样，修改客户端的hosts文件。在其中加入<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">172<span class="selector-class">.16</span><span class="selector-class">.0</span><span class="selector-class">.180</span> <span class="selector-tag">traefik</span><span class="selector-class">.ui</span><span class="selector-class">.com</span></span><br><span class="line">172<span class="selector-class">.16</span><span class="selector-class">.0</span><span class="selector-class">.180</span> <span class="selector-tag">k8s</span><span class="selector-class">.nginx</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure></p><p>所有访问这些地址的流量都会发送给172.16.0.180这台主机，就是我们启动traefik的主机。Traefik会解析http请求header里的Host参数将流量转发给Ingress配置里的相应service。<br><img src="/images/traefik-ui-nginx.png" alt="image"></p><p>在外部客户端，访问nginx应用的ingress地址<br><a href="http://k8s.nginx.com/" target="_blank" rel="noopener">http://k8s.nginx.com/</a></p><p><img src="/images/nginx-ui.png" alt="image"></p><p>在K8s集群节点上访问测试<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># curl -x 172.16.0.180:80 http:<span class="comment">//k8s.nginx.com</span></span></span><br></pre></td></tr></table></figure></p><h2 id="ingress配置同域名不同路径代理web应用"><a href="#ingress配置同域名不同路径代理web应用" class="headerlink" title="ingress配置同域名不同路径代理web应用"></a>ingress配置同域名不同路径代理web应用</h2><p>很多时候我们不想配置太多的域名来区别应用，使用同域名分路径的方式来区别应用就简洁方便很多。ingress也提供了相关的配置。</p><p>假设两个应用tomcat-test1和tomcat-test2。这里可配置域名tomcat.test.k8s，通过路径test1、test2来分别代理两个tomcat应用。其中，分路径配置需添加配置：traefik.frontend.rule.type: PathPrefixStrip<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vi ingress-tomcat.yaml </span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">tomcat-test-web</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line">    <span class="string">traefik.frontend.rule.type:</span> <span class="string">PathPrefixStrip</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">tomcat.test.k8s</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/test1/</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">tomcat-test1</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/test2/</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">tomcat-test2</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f ingress-tomcat.yaml                               </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl describe ingress tomcat-test-web</span></span><br></pre></td></tr></table></figure><p>从describe信息和ui界面上可以看到，tomcat.test.k8s分别有了/test1/和/test2/的域名代理以及相对应的后端，可以修改hosts测试一下分路径是否生效：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">172<span class="selector-class">.16</span><span class="selector-class">.0</span><span class="selector-class">.180</span>  <span class="selector-tag">tomcat</span><span class="selector-class">.test</span><span class="selector-class">.k8s</span></span><br></pre></td></tr></table></figure></p><p>测试访问<br><img src="/images/test-ui.png" alt="image"></p><h2 id="在线修改资源配置"><a href="#在线修改资源配置" class="headerlink" title="在线修改资源配置"></a>在线修改资源配置</h2><p>如果需要在线修改部署的资源，如deployment、service或ingress等，可以使用kubectl edit命令。如修改deployment。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl get deploy</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl edit deploy nginx-pod</span></span><br></pre></td></tr></table></figure></p><p>或者直接修改yaml文件后，执行kubectl apply命令更新即可生效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Traefik介绍&quot;&gt;&lt;a href=&quot;#Traefik介绍&quot; class=&quot;headerlink&quot; title=&quot;Traefik介绍&quot;&gt;&lt;/a&gt;Traefik介绍&lt;/h2&gt;&lt;p&gt;简单的说，ingress就是从kubernetes集群外访问集群的入口，将用户的UR
      
    
    </summary>
    
      <category term="Kubernetes" scheme="http://yoursite.com/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="http://yoursite.com/tags/Kubernetes/"/>
    
      <category term="traefik" scheme="http://yoursite.com/tags/traefik/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes Helm使用</title>
    <link href="http://yoursite.com/2019/03/01/Kubernetes-Helm%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/03/01/Kubernetes-Helm使用/</id>
    <published>2019-03-01T11:58:21.000Z</published>
    <updated>2019-03-13T13:00:18.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Helm"><a href="#什么是Helm" class="headerlink" title="什么是Helm"></a>什么是Helm</h2><p>在没使用helm之前，向kubernetes部署应用，我们要依次部署deployment、svc等，步骤较繁琐。况且随着很多项目微服务化，复杂的应用在容器中部署以及管理显得较为复杂，helm通过打包的方式，支持发布的版本管理和控制，很大程度上简化了Kubernetes应用的部署和管理.</p><p>Helm本质就是让K8s的应用管理（Deployment,Service等)可配置，能动态生成。通过动态生成K8s资源清单文件（deployment.yaml，service.yaml）。然后调用Kubectl自动执行K8s资源部署。</p><p><strong>Helm和charts的主要作用</strong></p><ul><li>应用程序封装</li><li>版本管理</li><li>依赖检查</li><li>便于应用程序分发</li></ul><p><strong>组成</strong><br>helm客户端</p><ul><li>制作、拉取、查找和验证 Chart</li><li>安装服务端Tiller</li><li>指示服务端Tiller做事，比如根据chart创建一个Release</li></ul><p>helm服务端 tiller</p><ul><li>安装在Kubernetes集群内的一个应用， 用来执行客户端发来的命令，管理Release</li></ul><h2 id="安装Helm客户端"><a href="#安装Helm客户端" class="headerlink" title="安装Helm客户端"></a>安装Helm客户端</h2><p>下载期望的版本<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># wget -c https:<span class="comment">//storage.googleapis.com/kubernetes-helm/helm-v2.12.3-linux-amd64.tar.gz</span></span></span><br></pre></td></tr></table></figure></p><p>解压<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">tar</span> <span class="selector-tag">-zxvf</span> <span class="selector-tag">helm-v2</span><span class="selector-class">.12</span><span class="selector-class">.3-linux-amd64</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure></p><p>在解压后的文件夹中找到Helm命令所在位置, 将它移动到期望位置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mv linux-amd64/helm /usr/<span class="built_in">local</span>/bin/helm</span></span><br></pre></td></tr></table></figure></p><h2 id="安装helm服务端tiller"><a href="#安装helm服务端tiller" class="headerlink" title="安装helm服务端tiller"></a>安装helm服务端tiller</h2><p>执行命令<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># helm init --upgrade --tiller-image registry.<span class="keyword">cn</span>-beijing.aliyuncs.<span class="keyword">com</span>/minminmsn/tiller:v2.<span class="number">12.3</span> --stable-repo-url http<span class="variable">s:</span>//kubernetes.oss-<span class="keyword">cn</span>-hangzhou.aliyuncs.<span class="keyword">com</span>/charts</span><br></pre></td></tr></table></figure></p><p>确认服务端tiller<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get pods -n kube-system |grep tiller</span><br><span class="line">tiller-deploy<span class="number">-99</span>dcdbf5f-ddwbg              <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">4</span>m28s</span><br></pre></td></tr></table></figure></p><p>确认客户端和服务端连接成功。如果只显示了客户端版本，说明没有连上服务端。 它会自动去K8s上kube-system命名空间下查找是否有Tiller的Pod在运行。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">helm</span> <span class="selector-tag">version</span></span><br><span class="line"><span class="selector-tag">Client</span>: &amp;<span class="selector-tag">version</span><span class="selector-class">.Version</span>&#123;<span class="attribute">SemVer</span>:<span class="string">"v2.12.3"</span>, GitCommit:<span class="string">"20adb27c7c5868466912eebdf6664e7390ebe710"</span>, GitTreeState:<span class="string">"clean"</span>&#125;</span><br><span class="line"><span class="selector-tag">Server</span>: &amp;<span class="selector-tag">version</span><span class="selector-class">.Version</span>&#123;<span class="attribute">SemVer</span>:<span class="string">"v2.12.3"</span>, GitCommit:<span class="string">"20adb27c7c5868466912eebdf6664e7390ebe710"</span>, GitTreeState:<span class="string">"clean"</span>&#125;</span><br></pre></td></tr></table></figure></p><p>查找helm仓库中可用chart，如查找mysql<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> helm search mysql</span></span><br></pre></td></tr></table></figure></p><p>默认安装的 tiller 权限很小，我们执行下面的脚本给它加最大权限，这样方便我们可以用 helm 部署应用到任意 namespace 下:<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># kubectl <span class="keyword">create</span> serviceaccount --<span class="keyword">namespace</span>=kube-<span class="keyword">system</span> tiller</span><br><span class="line"></span><br><span class="line"># kubectl <span class="keyword">create</span> clusterrolebinding tiller-<span class="keyword">cluster</span>-rule --clusterrole=<span class="keyword">cluster</span>-admin --serviceaccount=kube-<span class="keyword">system</span>:tiller</span><br><span class="line"></span><br><span class="line"># kubectl patch deploy --<span class="keyword">namespace</span>=kube-<span class="keyword">system</span> tiller-deploy -p <span class="string">'&#123;"spec":&#123;"template":&#123;"spec":&#123;"serviceAccount":"tiller"&#125;&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure></p><h2 id="创建自己的chart"><a href="#创建自己的chart" class="headerlink" title="创建自己的chart"></a>创建自己的chart</h2><p>我们创建一个名为mychart的chart，看一看chart的文件结构。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ helm create mongodb</span><br><span class="line">$ tree mongodb</span><br><span class="line">mongodb</span><br><span class="line">├── Chart.yaml <span class="comment">#Chart本身的版本和配置信息</span></span><br><span class="line">├── charts <span class="comment">#依赖的chart</span></span><br><span class="line">├── templates <span class="comment">#配置模板目录</span></span><br><span class="line">│   ├── NOTES.txt <span class="comment">#helm提示信息</span></span><br><span class="line">│   ├── _helpers.tpl <span class="comment">#用于修改kubernetes objcet配置的模板</span></span><br><span class="line"><span class="params">|     |</span>—— ingress.yaml  <span class="comment">#用于服务暴露或访问</span></span><br><span class="line">│   ├── deployment.yaml <span class="comment">#kubernetes Deployment object</span></span><br><span class="line">│   └── service.yaml <span class="comment">#kubernetes Serivce</span></span><br><span class="line">└── values.yaml <span class="comment">#kubernetes object configuration</span></span><br></pre></td></tr></table></figure></p><p>如此，我们可以按需编辑自动生成的yaml文件。templates目录下的yaml文件中的变量是从values.yaml文件中获取的。</p><p>使用命令验证chart配置。该输出中包含了模板的变量配置与最终渲染的yaml文件。<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">helm</span> <span class="comment">install</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">dry</span><span class="literal">-</span><span class="comment">run</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">debug</span> <span class="comment">mongodb</span></span><br></pre></td></tr></table></figure></p><h2 id="部署到kubernetes"><a href="#部署到kubernetes" class="headerlink" title="部署到kubernetes"></a>部署到kubernetes</h2><p>在mongodb目录下执行下面的命令将nginx部署到kubernetes集群上。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> helm install .</span></span><br></pre></td></tr></table></figure></p><p>查看部署的release<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">helm</span> <span class="selector-tag">list</span></span><br><span class="line"><span class="selector-tag">NAME</span>         <span class="selector-tag">REVISION</span><span class="selector-tag">UPDATED</span>                 <span class="selector-tag">STATUS</span>  <span class="selector-tag">CHART</span>        <span class="selector-tag">NAMESPACE</span></span><br><span class="line"><span class="selector-tag">garish-gopher</span>1       <span class="selector-tag">Wed</span> <span class="selector-tag">Feb</span> 27 11<span class="selector-pseudo">:24</span><span class="selector-pseudo">:36</span> 2019<span class="selector-tag">DEPLOYED</span><span class="selector-tag">mongodb-0</span><span class="selector-class">.1</span><span class="selector-class">.0</span><span class="selector-tag">default</span></span><br></pre></td></tr></table></figure></p><h2 id="打包分享"><a href="#打包分享" class="headerlink" title="打包分享"></a>打包分享</h2><p>我们可以修改Chart.yaml中的helm chart配置信息，然后使用下列命令将chart打包成一个压缩文件。<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># helm <span class="keyword">package</span> <span class="title">.</span></span><br></pre></td></tr></table></figure></p><p>打包出mongodb-0.1.0.tgz文件。</p><p><strong>依赖</strong><br>我们可以在requirements.yaml中定义应用所依赖的chart，例如定义对mariadb的依赖：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">dependencies</span>:</span><br><span class="line">- <span class="attribute">name</span>: mariadb</span><br><span class="line">  <span class="attribute">version</span>: <span class="number">0.6</span>.<span class="number">0</span></span><br><span class="line">  <span class="attribute">repository</span>: <span class="attribute">https</span>:<span class="comment">//kubernetes-charts.storage.googleapis.com</span></span><br></pre></td></tr></table></figure></p><p>使用helm lint .命令可以检查依赖和模板配置是否正确。</p><h2 id="使用第三方chat库"><a href="#使用第三方chat库" class="headerlink" title="使用第三方chat库"></a>使用第三方chat库</h2><p>添加fabric8库<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># helm repo add fabric8 https:<span class="comment">//fabric8.io/helm</span></span></span><br></pre></td></tr></table></figure></p><p>搜索fabric8提供的工具（主要就是fabric8-platform工具包，包含了CI、CD的全套工具）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> helm search fabric8</span></span><br></pre></td></tr></table></figure></p><p>我们在前面打包的chart可以通过HTTP server的方式提供。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">helm</span> <span class="selector-tag">serve</span> <span class="selector-tag">--address</span> 172<span class="selector-class">.16</span><span class="selector-class">.0</span><span class="selector-class">.180</span><span class="selector-pseudo">:8879</span></span><br><span class="line"><span class="selector-tag">Regenerating</span> <span class="selector-tag">index</span>. <span class="selector-tag">This</span> <span class="selector-tag">may</span> <span class="selector-tag">take</span> <span class="selector-tag">a</span> <span class="selector-tag">moment</span>.</span><br><span class="line"><span class="selector-tag">Now</span> <span class="selector-tag">serving</span> <span class="selector-tag">you</span> <span class="selector-tag">on</span> 172<span class="selector-class">.16</span><span class="selector-class">.0</span><span class="selector-class">.180</span><span class="selector-pseudo">:8879</span></span><br></pre></td></tr></table></figure></p><p>访问<a href="http://172.16.0.180:8879可以看到刚刚安装的chart。" target="_blank" rel="noopener">http://172.16.0.180:8879可以看到刚刚安装的chart。</a><br><img src="/images/helm-k8s.png" alt="image"></p><p><strong>解决本地chart依赖</strong><br>打开另外一个终端，在本地当前chart配置的目录下，将该repo加入到repo list中。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> helm repo add <span class="built_in">local</span> http://172.16.0.180:8879</span></span><br></pre></td></tr></table></figure></p><p>在浏览器中访问<a href="http://172.16.0.180:8879，可以看到所有本地的chart。" target="_blank" rel="noopener">http://172.16.0.180:8879，可以看到所有本地的chart。</a></p><p>然后下载依赖到本地。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> helm dependency update</span></span><br></pre></td></tr></table></figure></p><p>这样所有的chart都会下载到本地的charts目录下。</p><p>设置helm命令自动补全<br>为了方便helm命令的使用，helm提供了自动补全功能，如果使用bash请执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">source</span> &lt;(helm completion bash)</span></span><br></pre></td></tr></table></figure></p><p><strong>Example: 安装Mysql</strong><br>执行命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> helm repo update</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> helm install stable/mysql</span></span><br><span class="line">Released smiling-penguin</span><br></pre></td></tr></table></figure></p><p>每次安装都有一个Release被创建， 所以一个Chart可以在同一个集群中被安装多次，每一个都是独立管理和升级的。其中 stable/mysql是Chart名， smiling-penguid 是Release名，后面管理Release时都是用的这个名字。</p><p>在使用一个Chart前，查看它的默认配置，然后使用配置文件覆盖它的默认设置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> helm inspect values stable/mariadb</span></span><br></pre></td></tr></table></figure></p><p>使用一个YAML文件，内含要覆盖Chart的配置值。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&#123;mariadbUser: user0, mariadbDatabase: user0db&#125;'</span> &gt; config.yaml</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> helm install -f config.yaml stable/mariadb</span></span><br></pre></td></tr></table></figure></p><p>values.yaml中的值可以被部署release时用到的参数–values YAML_FILE_PATH 或 –set key1=value1, key2=value2覆盖掉， 比如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> helm install --<span class="built_in">set</span> image.tag=<span class="string">'latest'</span> .</span></span><br></pre></td></tr></table></figure></p><p>优先级： –set设置的值会覆盖–value设置的值， –value设置的值会覆盖 values.yaml中定义的值</p><h2 id="helm一些常用命令"><a href="#helm一些常用命令" class="headerlink" title="helm一些常用命令"></a>helm一些常用命令</h2><p><strong>Charts:</strong><br>helm search 查找可用的Charts<br>helm inspect 查看指定Chart的基本信息<br>helm install 根据指定的Chart 部署一个Release到K8s<br>helm create 创建自己的Chart<br>helm package 打包Chart，一般是一个压缩包文件</p><p><strong>release:</strong><br>helm list 列出已经部署的Release<br>helm delete [RELEASE] 删除一个Release. 并没有物理删除， 出于审计需要，历史可查。<br>helm status [RELEASE] 查看指定的Release信息，即使使用helm delete命令删除的Release.<br>helm upgrade 升级某个Release<br>helm rollback [RELEASE] [REVISION] 回滚Release到指定发布版本<br>helm get values [RELEASE] 查看Release的配置文件值<br>helm ls –deleted 列出已经删除的Release</p><p><strong>repo:</strong><br>helm repo list<br>helm repo add [RepoName] [RepoUrl]<br>helm repo update</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Helm&quot;&gt;&lt;a href=&quot;#什么是Helm&quot; class=&quot;headerlink&quot; title=&quot;什么是Helm&quot;&gt;&lt;/a&gt;什么是Helm&lt;/h2&gt;&lt;p&gt;在没使用helm之前，向kubernetes部署应用，我们要依次部署deployment、svc等，
      
    
    </summary>
    
      <category term="Kubernetes" scheme="http://yoursite.com/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="http://yoursite.com/tags/Kubernetes/"/>
    
      <category term="Helm" scheme="http://yoursite.com/tags/Helm/"/>
    
  </entry>
  
  <entry>
    <title>使用client-go自定义开发Kubernetes</title>
    <link href="http://yoursite.com/2019/02/13/%E4%BD%BF%E7%94%A8client-go%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91Kubernetes/"/>
    <id>http://yoursite.com/2019/02/13/使用client-go自定义开发Kubernetes/</id>
    <published>2019-02-13T14:39:09.000Z</published>
    <updated>2019-03-01T12:54:06.261Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 1. 安装client-go </strong></p><p>client-go 安装很简单，前提是本机已经安装并配置好了 Go 环境，安装之前，我们需要先查看下其版本针对 k8s 版本 兼容性列表，针对自己本机安装的 k8s 版本选择对应的 client-go 版本，当然也可以默认选择最新版本，来兼容所有。</p><p>client-go 安装方式有多种，比如 go get、Godep、Glide 方式。如果我们本地没有安装 Godep 和 Glide 依赖管理工具的话，可以使用最简单的 go get 下载安装。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">go</span> <span class="built_in">get</span> k8s.io/client-<span class="built_in">go</span>/...</span><br></pre></td></tr></table></figure></p><p>执行该命令将会自动将 k8s.io/client-go 下载到本机 $GOPATH，默认下载的源码中只包含了大部分依赖，并将其放在 k8s.io/client-go/vendor 路径，但是如果想成功运行的话，还需要另外两个依赖库 k8s.io/client-go/vendor 和 glog，所以还需要接着执行如下命令。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="builtin-name">get</span> -u k8s.io/apimachinery/<span class="built_in">..</span>.</span><br></pre></td></tr></table></figure></p><p>说明一下，为什么要使用 -u 参数来拉取最新的该依赖库呢？那是因为最新的 client-go 库只能保证跟最新的 apimachinery 库一起运行。</p><p><strong> 2. 在k8s集群外操作资源示例 </strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"># cat main.<span class="keyword">go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">metav1 <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line"><span class="string">"k8s.io/client-go/kubernetes"</span></span><br><span class="line"><span class="string">"k8s.io/client-go/tools/clientcmd"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 配置 k8s 集群外 kubeconfig 配置文件</span></span><br><span class="line"><span class="keyword">var</span> kubeconfig *<span class="keyword">string</span></span><br><span class="line">kubeconfig = flag.String(<span class="string">"kubeconfig"</span>, <span class="string">"/etc/kubernetes/admin.conf"</span>, <span class="string">"absolute path to the kubeconfig file"</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 kubeconfig 中使用当前上下文环境，config 获取支持 url 和 path 方式</span></span><br><span class="line">config, err := clientcmd.BuildConfigFromFlags(<span class="string">""</span>, *kubeconfig)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的 config 创建一个新的 clientset</span></span><br><span class="line">clientset, err := kubernetes.NewForConfig(config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 通过实现 clientset 的 CoreV1Interface 接口列表中的 PodsGetter 接口方法 Pods(namespace string)返回 PodInterface</span></span><br><span class="line"><span class="comment">// PodInterface 接口拥有操作 Pod 资源的方法，例如 Create、Update、Get、List 等方法</span></span><br><span class="line"><span class="comment">// 注意：Pods() 方法中 namespace 不指定则获取 Cluster 所有 Pod 列表</span></span><br><span class="line">pods, err := clientset.CoreV1().Pods(<span class="string">""</span>).List(metav1.ListOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"There are %d pods in the k8s cluster\n"</span>, <span class="built_in">len</span>(pods.Items))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定 namespace 中的 Pod 列表信息</span></span><br><span class="line">namespace := <span class="string">"default"</span></span><br><span class="line">pods, err = clientset.CoreV1().Pods(namespace).List(metav1.ListOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"\nThere are %d pods in namespaces %s\n"</span>, <span class="built_in">len</span>(pods.Items), namespace)</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods.Items &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Name: %s, Status: %s, CreateTime: %s\n"</span>, pod.ObjectMeta.Name, pod.Status.Phase, pod.ObjectMeta.CreationTimestamp)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prettyPrint</span><span class="params">(maps <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">lens := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k, _ := <span class="keyword">range</span> maps &#123;</span><br><span class="line"><span class="keyword">if</span> lens &lt;= <span class="built_in">len</span>(k) &#123;</span><br><span class="line">lens = <span class="built_in">len</span>(k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key, values := <span class="keyword">range</span> maps &#123;</span><br><span class="line">spaces := lens - <span class="built_in">len</span>(key)</span><br><span class="line">v := <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; spaces; i++ &#123;</span><br><span class="line">v += <span class="string">" "</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s: %s%v\n"</span>, key, v, values)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">homeDir</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> h := os.Getenv(<span class="string">"HOME"</span>); h != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> os.Getenv(<span class="string">"USERPROFILE"</span>) <span class="comment">// windows</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行程序<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go run main.go</span></span><br><span class="line">There are 15 pods <span class="keyword">in</span> the k8s cluster</span><br><span class="line"></span><br><span class="line">There are 2 pods <span class="keyword">in</span> namespaces default</span><br><span class="line">Name: podinfo-7b8c9bc5c9-64g8k, Status: Running, CreateTime: 2019-01-10 22:40:18 +0800 CST</span><br><span class="line">Name: podinfo-7b8c9bc5c9-bx7ml, Status: Running, CreateTime: 2019-01-10 22:40:18 +0800 CST</span><br><span class="line">There are 15 pods <span class="keyword">in</span> the k8s cluster</span><br></pre></td></tr></table></figure></p><p><strong> 3.在k8s集群内操作资源示例 </strong><br>除以上方法外，还可以在 k8s 集群内运行客户端操作资源类型。既然是在 k8s 集群内运行，那么就需要将编写的代码放到镜像内，然后在 k8s 集群内以 Pod 方式运行该镜像容器。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"># cat main2.<span class="keyword">go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">metav1 <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line"><span class="string">"k8s.io/client-go/kubernetes"</span></span><br><span class="line"><span class="string">"k8s.io/client-go/rest"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 通过集群内部配置创建 k8s 配置信息，通过 KUBERNETES_SERVICE_HOST 和 KUBERNETES_SERVICE_PORT 环境变量方式获取</span></span><br><span class="line"><span class="comment">// 若集群使用 TLS 认证方式，则默认读取集群内部 tokenFile 和 CAFile</span></span><br><span class="line"><span class="comment">// tokenFile  = "/var/run/secrets/kubernetes.io/serviceaccount/token"</span></span><br><span class="line"><span class="comment">// rootCAFile = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"</span></span><br><span class="line">config, err := rest.InClusterConfig()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的 config 创建一个新的 clientset</span></span><br><span class="line">clientset, err := kubernetes.NewForConfig(config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 通过实现 clientset 的 CoreV1Interface 接口列表中的 PodsGetter 接口方法 Pods(namespace string)返回 PodInterface</span></span><br><span class="line"><span class="comment">// PodInterface 接口拥有操作 Pod 资源的方法，例如 Create、Update、Get、List 等方法</span></span><br><span class="line"><span class="comment">// 注意：Pods() 方法中 namespace 不指定则获取 Cluster 所有 Pod 列表</span></span><br><span class="line">pods, err := clientset.CoreV1().Pods(<span class="string">""</span>).List(metav1.ListOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"There are %d pods in the k8s cluster\n"</span>, <span class="built_in">len</span>(pods.Items))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定 namespace 中的 Pod 列表信息</span></span><br><span class="line">namespce := <span class="string">"default"</span></span><br><span class="line">pods, err = clientset.CoreV1().Pods(namespce).List(metav1.ListOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"\nThere are %d pods in namespaces %s\n"</span>, <span class="built_in">len</span>(pods.Items), namespce)</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods.Items &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Name: %s, Status: %s, CreateTime: %s\n"</span>, pod.ObjectMeta.Name, pod.Status.Phase, pod.ObjectMeta.CreationTimestamp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有的 Namespaces 列表信息</span></span><br><span class="line">ns, err := clientset.CoreV1().Namespaces().List(metav1.ListOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">nss := ns.Items</span><br><span class="line">fmt.Printf(<span class="string">"\nThere are %d namespaces in cluster\n"</span>, <span class="built_in">len</span>(nss))</span><br><span class="line"><span class="keyword">for</span> _, ns := <span class="keyword">range</span> nss &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Name: %s, Status: %s, CreateTime: %s\n"</span>, ns.ObjectMeta.Name, ns.Status.Phase, ns.CreationTimestamp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该示例主要演示如何在 k8s 集群内操作 Pod 和 Namespaces 资源类型，包括获取集群所有 Pod 列表数量，获取指定 Namespace 中的 Pod 列表信息，获取集群内所有 Namespace 列表信息。这里，该方式获取 k8s 集群配置的方式跟上边方式不同，它通过集群内部创建的 k8s 配置信息，通过 KUBERNETES_SERVICE_HOST 和 KUBERNETES_SERVICE_PORT 环境变量方式获取，来跟 k8s 建立连接，进而来操作其各个资源类型。如果 k8s 开启了 TLS 认证方式，那么默认读取集群内部指定位置的 tokenFile 和 CAFile。</p><p>编译一下，看下是否通过。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> go build main2.go</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls</span></span><br><span class="line">main2  main2.go</span><br></pre></td></tr></table></figure></p><p>接下来，在同级目录创建一个 Dockerfile 文件如下<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./main2 /opt</span></span><br><span class="line"><span class="bash">ENTRYPOINT /opt/main2</span></span><br></pre></td></tr></table></figure></p><p>构建docker镜像<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls</span></span><br><span class="line">Dockerfile  main2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker build -t client-go/<span class="keyword">in</span>-cluster:1.0 .</span></span><br></pre></td></tr></table></figure></p><p>因为本机 k8s 默认开启了 RBAC 认证的，所以需要创建一个 clusterrolebinding 来赋予 default 账户 view 权限。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create clusterrolebinding default-view --clusterrole=view --serviceaccount=default:default</span><br><span class="line">clusterrolebinding<span class="selector-class">.rbac</span><span class="selector-class">.authorization</span><span class="selector-class">.k8s</span><span class="selector-class">.io</span> <span class="string">"default-view"</span> created</span><br></pre></td></tr></table></figure></p><p>最后，在 Pod 中运行该镜像即可，可以使用 yaml 方式或运行 kubectl run 命令来创建。<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># kubectl run --rm -i client-go-in-cluster-demo --image=client-go/in-cluster:1.0 --image-pull-policy=Never</span><br><span class="line"></span><br><span class="line">There are 3 pods in namespaces default</span><br><span class="line">Name: client-go-in-cluster-demo<span class="string">-58</span>d9b5bd79<span class="string">-7</span>w5ds, Status: Running, CreateTime: 2019<span class="string">-02</span><span class="string">-13</span> 14:25:38 <span class="string">+0000</span> UTC</span><br><span class="line">Name: podinfo<span class="string">-7</span>b8c9bc5c9<span class="string">-64</span>g8k, Status: Running, CreateTime: 2019<span class="string">-01</span><span class="string">-10</span> 14:40:18 <span class="string">+0000</span> UTC</span><br><span class="line">Name: podinfo<span class="string">-7</span>b8c9bc5c9-bx7ml, Status: Running, CreateTime: 2019<span class="string">-01</span><span class="string">-10</span> 14:40:18 <span class="string">+0000</span> UTC</span><br><span class="line"></span><br><span class="line">There are 5 namespaces in cluster</span><br><span class="line">Name: custom-metrics, Status: Active, CreateTime: 2019<span class="string">-01</span><span class="string">-10</span> 09:01:52 <span class="string">+0000</span> UTC</span><br><span class="line">Name: default, Status: Active, CreateTime: 2019<span class="string">-01</span><span class="string">-05</span> 09:18:02 <span class="string">+0000</span> UTC</span><br><span class="line">Name: kube-public, Status: Active, CreateTime: 2019<span class="string">-01</span><span class="string">-05</span> 09:18:02 <span class="string">+0000</span> UTC</span><br><span class="line">Name: kube-system, Status: Active, CreateTime: 2019<span class="string">-01</span><span class="string">-05</span> 09:18:02 <span class="string">+0000</span> UTC</span><br><span class="line">Name: monitoring, Status: Active, CreateTime: 2019<span class="string">-01</span><span class="string">-08</span> 15:00:41 <span class="string">+0000</span> UTC</span><br><span class="line">There are 16 pods in the k8s cluster</span><br></pre></td></tr></table></figure></p><p>运行正常，简单验证一下吧！<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get pods -n <span class="section">default</span></span><br><span class="line">NAME                                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">client-go-in-cluster-demo<span class="number">-58</span>d9b5bd79<span class="number">-7</span>w5ds   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">10</span>m</span><br><span class="line">podinfo<span class="number">-7</span>b8c9bc5c9<span class="number">-64</span>g8k                     <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">1</span>          <span class="number">33</span>d</span><br><span class="line">podinfo<span class="number">-7</span>b8c9bc5c9-bx7ml                     <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">1</span>          <span class="number">33</span>d</span><br></pre></td></tr></table></figure></p><p><strong> 4. k8s各资源对象CRUD操作 </strong><br>上边演示了，在 k8s 集群内外运行客户端操作资源类型，但是仅仅是 Read 相关读取操作，接下来简单演示下如何进行 Create、Update、Delete 操作。创建 main.go 文件如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># cat main3.<span class="keyword">go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">apiv1 <span class="string">"k8s.io/api/core/v1"</span></span><br><span class="line">metav1 <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line"><span class="string">"k8s.io/client-go/kubernetes"</span></span><br><span class="line"><span class="string">"k8s.io/client-go/tools/clientcmd"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 配置 k8s 集群外 kubeconfig 配置文件</span></span><br><span class="line"><span class="keyword">var</span> kubeconfig *<span class="keyword">string</span></span><br><span class="line">    kubeconfig = flag.String(<span class="string">"kubeconfig"</span>, <span class="string">"/etc/kubernetes/admin.conf"</span>, <span class="string">"absolute path to the kubeconfig file"</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 kubeconfig 中使用当前上下文环境，config 获取支持 url 和 path 方式</span></span><br><span class="line">config, err := clientcmd.BuildConfigFromFlags(<span class="string">""</span>, *kubeconfig)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的 config 创建一个新的 clientset</span></span><br><span class="line">clientset, err := kubernetes.NewForConfig(config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过实现 clientset 的 CoreV1Interface 接口列表中的 NamespacesGetter 接口方法 Namespaces 返回 NamespaceInterface</span></span><br><span class="line"><span class="comment">// NamespaceInterface 接口拥有操作 Namespace 资源的方法，例如 Create、Update、Get、List 等方法</span></span><br><span class="line">name := <span class="string">"client-go-test"</span></span><br><span class="line">namespacesClient := clientset.CoreV1().Namespaces()</span><br><span class="line">namespace := &amp;apiv1.Namespace&#123;</span><br><span class="line">ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">Name: name,</span><br><span class="line">&#125;,</span><br><span class="line">Status: apiv1.NamespaceStatus&#123;</span><br><span class="line">Phase: apiv1.NamespaceActive,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的 Namespaces</span></span><br><span class="line">fmt.Println(<span class="string">"Creating Namespaces..."</span>)</span><br><span class="line">result, err := namespacesClient.Create(namespace)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Created Namespaces %s on %s\n"</span>, result.ObjectMeta.Name, result.ObjectMeta.CreationTimestamp)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定名称的 Namespaces 信息</span></span><br><span class="line">fmt.Println(<span class="string">"Getting Namespaces..."</span>)</span><br><span class="line">result, err = namespacesClient.Get(name, metav1.GetOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Name: %s, Status: %s, selfLink: %s, uid: %s\n"</span>,</span><br><span class="line">result.ObjectMeta.Name, result.Status.Phase, result.ObjectMeta.SelfLink, result.ObjectMeta.UID)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定名称的 Namespaces 信息</span></span><br><span class="line">fmt.Println(<span class="string">"Deleting Namespaces..."</span>)</span><br><span class="line">deletePolicy := metav1.DeletePropagationForeground</span><br><span class="line"><span class="keyword">if</span> err := namespacesClient.Delete(name, &amp;metav1.DeleteOptions&#123;</span><br><span class="line">PropagationPolicy: &amp;deletePolicy,</span><br><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Deleted Namespaces %s\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行程序<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">go</span> run main3.<span class="keyword">go</span></span><br><span class="line">Creating Namespaces...</span><br><span class="line">Created Namespaces client-<span class="keyword">go</span>-test <span class="keyword">on</span> <span class="number">2019</span>-<span class="number">02</span>-<span class="number">13</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">52</span> +<span class="number">0800</span> CST</span><br><span class="line">Getting Namespaces...</span><br><span class="line">Name: client-<span class="keyword">go</span>-test, Statu<span class="variable">s:</span> Active, selfLink: /api/v1/namespaces/client-<span class="keyword">go</span>-test, uid: <span class="number">8</span>a2de86e-<span class="number">2</span>f95-<span class="number">11</span>e9-b2e0-a0369f3f0404</span><br><span class="line">Deleting Namespaces...</span><br><span class="line">Deleted Namespaces client-<span class="keyword">go</span>-test</span><br></pre></td></tr></table></figure></p><p>参考资料<br><a href="https://blog.csdn.net/aixiaoyang168/article/details/84752005" target="_blank" rel="noopener">https://blog.csdn.net/aixiaoyang168/article/details/84752005</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 1. 安装client-go &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;client-go 安装很简单，前提是本机已经安装并配置好了 Go 环境，安装之前，我们需要先查看下其版本针对 k8s 版本 兼容性列表，针对自己本机安装的 k8s 版本选择对应的 clien
      
    
    </summary>
    
      <category term="Kubernetes" scheme="http://yoursite.com/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="http://yoursite.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>编译和运行Kubernetes源码</title>
    <link href="http://yoursite.com/2019/01/26/%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8CKubernetes%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2019/01/26/编译和运行Kubernetes源码/</id>
    <published>2019-01-26T11:51:09.000Z</published>
    <updated>2019-03-01T12:53:39.676Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 为什么要编译源码 </strong><br>Kubernetes是一个非常棒的容器集群管理平台。通常情况下，我们并不需要修改K8s代码即可直接使用。但如果，我们在环境中发现了某个问题/缺陷，或按照特定业务需求需要修改K8s代码时，如定制Kubelet的StopContainer 逻辑、kube-scheduler的pod调度逻辑等。为了让修改生效，那么就需要编译K8s代码了。</p><p>Kubernetes源码编译，大致分为本地二进制可执行文件编译和docker镜像编译两种。由于在我们的环境中，Kubernetes是由Docker容器方式运行的。故此我们需要采用后面一种方式编译，即镜像编译。</p><p>由于Kubernetes每个组件服务的镜像Dockerfile文件是由Kubernetes源码自动生成的，因此，社区并未提供每个组件的镜像Dockerfile文件。编译本地二进制可执行文件很简单，也更直接。而docker镜像编译资料却很少，且碍于某种特殊网络原因，会导致失败。此处，将介绍如何顺利的完成k8s镜像编译。</p><p><strong> 安装依赖 </strong><br>安装Golang<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -<span class="keyword">c</span> http<span class="variable">s:</span>//<span class="keyword">dl</span>.google.<span class="keyword">com</span>/<span class="keyword">go</span>/go1.<span class="number">11.4</span>.linux-amd64.tar.gz -<span class="keyword">P</span> /<span class="keyword">opt</span>/</span><br><span class="line"><span class="keyword">cd</span> /<span class="keyword">opt</span>/</span><br><span class="line">tar -C /usr/local -xzf go1.<span class="number">11.4</span>.linux-amd64.tar.gz </span><br><span class="line"><span class="keyword">echo</span> <span class="string">"export PATH=$PATH:/usr/local/go/bin"</span> &gt;&gt; /etc/<span class="keyword">profile</span> &amp;&amp; <span class="keyword">source</span> /etc/<span class="keyword">profile</span></span><br></pre></td></tr></table></figure></p><p>指定分支，下载 Kubernetes 源代码（默认$GOPATH目录为/root/go/）<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -<span class="selector-tag">p</span> <span class="variable">$GOPATH</span>/src/k8s.io</span><br><span class="line">cd <span class="variable">$GOPATH</span>/src/k8s.io</span><br><span class="line">git clone  https:<span class="comment">//github.com/kubernetes/kubernetes -b release-1.13</span></span><br><span class="line">cd <span class="variable">$GOPATH</span>/src/k8s.io/kubernetes</span><br></pre></td></tr></table></figure></p><p><strong> 本地二进制文件编译Kubernetes（方法一） </strong><br>修改运行平台配置参数（可选）<br>根据自己的运行平台（linux/amd64)修改hack/lib/golang.sh，把KUBE_SERVER_PLATFORMS，KUBE_CLIENT_PLATFORMS和KUBE_TEST_PLATFORMS中除linux/amd64以外的其他平台注释掉，以此来减少编译所用时间。</p><p>编译源码<br>进入Kubernetes根目录下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> kubernetes</span><br></pre></td></tr></table></figure></p><p>KUBE_BUILD_PLATFORMS指定目标平台，WHAT指定编译的组件，通过GOFLAGS和GOGCFLAGS传入编译时参数，如此处编译kubelet 组件。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">KUBE_BUILD_PLATFORMS</span>=linux/amd64 make all <span class="attribute">WHAT</span>=cmd/kubelet <span class="attribute">GOFLAGS</span>=-v <span class="attribute">GOGCFLAGS</span>=<span class="string">"-N -l"</span></span><br></pre></td></tr></table></figure></p><ul><li>如果不指定WHAT，则编译全部。</li><li>make all是在本地环境中进行编译的。</li><li>make release和make quick-release在容器中完成编译、打包成docker镜像。</li><li>编译kubelet这部分代码，也可执行make clean &amp;&amp; make WHAT=cmd/kubelet</li></ul><p>检查编译成果<br>编译过程较长，请耐心等待，编译后的文件在kubernetes/_output里。</p><p>或者进入cmd/kubelet (以kubelet为例子)<br>执行go build -v命令,如果没出错,会生成可执行文件kubelet<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">go</span> <span class="keyword">build </span>-v</span><br></pre></td></tr></table></figure></p><p>生成的可执行文件在当前文件夹下面<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ls <span class="meta-keyword">cmd</span>/kubelet/</span></span><br><span class="line">app  BUILD  kubelet  kubelet.go  OWNERS</span><br></pre></td></tr></table></figure></p><p><strong> Docker镜像编译Kubernetes（方法二） </strong></p><p>查看kube-cross的TAG版本号<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat ./build/build-image/cross/VERSION</span><br><span class="line">v1<span class="number">.11</span><span class="number">.4</span><span class="number">-1</span></span><br></pre></td></tr></table></figure></p><p>查看debian_iptables_version版本号<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># egrep -Rn <span class="string">"debian_iptables_version="</span> ./</span></span><br><span class="line">./build/common.sh:<span class="number">93</span>:  <span class="keyword">local</span> debian_iptables_version=v11<span class="number">.0</span></span><br></pre></td></tr></table></figure></p><p>这里，我使用DockerHub的Auto build功能，来构建K8s镜像。自然将编译需要用到的base镜像，放在了DockerHub上（也算是为促进国内K8s源码docker编译贡献绵薄之力吧！）。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker pull xiaoxu780/<span class="keyword">pause</span>-amd64:<span class="number">3.1</span></span><br><span class="line">docker pull xiaoxu780/kube-cross:v1<span class="meta">.11</span><span class="meta">.2</span>-<span class="number">1</span></span><br><span class="line">docker pull xiaoxu780/debian-base-amd64:<span class="number">0.4</span><span class="meta">.0</span></span><br><span class="line">docker pull xiaoxu780/debian-iptables-amd64:v11<span class="meta">.0</span></span><br><span class="line">docker pull xiaoxu780/debian-hyperkube-base-amd64:<span class="number">0.12</span><span class="meta">.0</span></span><br><span class="line"></span><br><span class="line">docker tag xiaoxu780/<span class="keyword">pause</span>-amd64:<span class="number">3.1</span> k8s.gcr.io/<span class="keyword">pause</span>-amd64:<span class="number">3.1</span></span><br><span class="line">docker tag xiaoxu780/kube-cross:v1<span class="meta">.11</span><span class="meta">.2</span>-<span class="number">1</span> k8s.gcr.io/kube-cross:v1<span class="meta">.11</span><span class="meta">.4</span>-<span class="number">1</span></span><br><span class="line">docker tag xiaoxu780/debian-base-amd64:<span class="number">0.4</span><span class="meta">.0</span> k8s.gcr.io/debian-base-amd64:<span class="number">0.4</span><span class="meta">.0</span></span><br><span class="line">docker tag xiaoxu780/debian-iptables-amd64:v11<span class="meta">.0</span> k8s.gcr.io/debian-iptables-amd64:v11<span class="meta">.0</span></span><br><span class="line">docker tag xiaoxu780/debian-hyperkube-base-amd64:<span class="number">0.12</span><span class="meta">.0</span> k8s.gcr.io/debian-hyperkube-base-amd64:<span class="number">0.12</span><span class="meta">.0</span></span><br></pre></td></tr></table></figure></p><p>把build/lib/release.sh中的–pull去掉，避免构建镜像继续拉取镜像：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">"<span class="variable">$&#123;DOCKER[@]&#125;</span>"</span> build --pull -q -t <span class="string">"<span class="variable">$&#123;docker_image_tag&#125;</span>"</span> <span class="variable">$&#123;docker_build_path&#125;</span> &gt;/dev/<span class="literal">null</span></span><br><span class="line">修改为:</span><br><span class="line"> <span class="string">"<span class="variable">$&#123;DOCKER[@]&#125;</span>"</span> build -q -t <span class="string">"<span class="variable">$&#123;docker_image_tag&#125;</span>"</span> <span class="variable">$&#123;docker_build_path&#125;</span> &gt;/dev/<span class="literal">null</span></span><br></pre></td></tr></table></figure></p><p>编辑文件hack/lib/version.sh<br>将KUBE_GIT_TREE_STATE=”dirty” 改为 KUBE_GIT_TREE_STATE=”clean”，确保版本号干净。</p><p>执行编译命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> kubernetes</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make clean</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> KUBE_BUILD_PLATFORMS=linux/amd64 KUBE_BUILD_CONFORMANCE=n KUBE_BUILD_HYPERKUBE=n make release-images GOFLAGS=-v GOGCFLAGS=<span class="string">"-N -l"</span></span></span><br></pre></td></tr></table></figure></p><p>其中KUBE_BUILD_PLATFORMS=linux/amd64指定目标平台为linux/amd64，GOFLAGS=-v开启verbose日志，GOGCFLAGS=”-N -l”禁止编译优化和内联，减小可执行程序大小。</p><p>编译的K8s Docker镜像以压缩包的形式发布在_output/release-tars目录中<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls _output/release-images/amd64/</span></span><br><span class="line"><span class="keyword">cloud-controller-manager.tar </span> kube-controller-manager.tar  kube-<span class="keyword">scheduler.tar</span></span><br><span class="line"><span class="keyword">kube-apiserver.tar </span>           kube-proxy.tar</span><br></pre></td></tr></table></figure></p><p><strong> 使用编译镜像 </strong></p><p>等待编译完成后，在_output/release-stage/server/linux-amd64/kubernetes/server/bin/目录下保存了编译生成的二进制可执行程序和docker镜像tar包。如导入kube-apiserver.tar镜像，并更新环境上部署的kube-apiserver镜像。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker load -i kube-apiserver.tar</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker tag k8s.gcr.io/kube-apiserver:v1.13.3  registry.com/kube-apiserver:v1.13.3</span></span><br></pre></td></tr></table></figure></p><p>整个编译过程结束后，现在就可以到master节点上，修改/etc/kubernetes/manifests/kube-apiserver.yaml描述文件中的image，修改完立即生效。</p><p>参考资料：<br><a href="https://github.com/kubernetes/kubernetes/tree/master/build/" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/tree/master/build/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; 为什么要编译源码 &lt;/strong&gt;&lt;br&gt;Kubernetes是一个非常棒的容器集群管理平台。通常情况下，我们并不需要修改K8s代码即可直接使用。但如果，我们在环境中发现了某个问题/缺陷，或按照特定业务需求需要修改K8s代码时，如定制Kubelet的St
      
    
    </summary>
    
      <category term="Kubernetes" scheme="http://yoursite.com/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="http://yoursite.com/tags/Kubernetes/"/>
    
      <category term="源码编译" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
</feed>
