<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何获取Kolla的OpenStack镜像]]></title>
    <url>%2F2018%2F05%2F07%2F%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Kolla%E7%9A%84OpenStack%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[由于，OpenStack社区自Queens版本起，便不再提供将打包好的kolla openstack镜像放在该链接上 所以，我们要获取Kolla的OpenStack镜像，就只能依靠自己手动获取。有如下几种方法。 从官方源下载镜像安装kolla-ansible12# git clone https://github.com/openstack/kolla-ansible -b stable/queens# pip install kolla-ansible/ 编辑globals.yml文件，设置相关参数1234# vim /etc/kolla/globals.ymlkolla_install_type: "source"kolla_base_distro: "centos"openstack_release: "queens" 下载镜像12# kolla-ansible -i all-in-one bootstrap-servers# kolla-ansible pull 手动构建镜像下载kolla项目1# git clone https://github.com/openstack/kolla.git -b stable/queens 生成kolla-build.conf文件123# pip install tox# cd kolla/# tox -e genconfig 构建openstack镜像12345//构建基于centos系统的source源码安装的openstack镜像# kolla-build -t source -b centos//或者，构建基于centos系统的binary二进制包安装的openstack镜像# kolla-build -t binary -b centos 自动化拉取kolla镜像由于OpenStack社区，已经开始正式将kolla镜像托管在DockerHub上。所以，我们还可以从Docker Hub上直接拉取kolla镜像，由于openstack镜像少则几十，多则上百，因此，这里我编写了一个bash脚本，用于自动化拉取queens版本的kolla镜像。 为了加快从docker hub上拉取镜像，这里，配置上阿里云的镜像加速器。1234# cat /etc/docker/daemon.json &#123;"registry-mirrors": ["https://a5aghnme.mirror.aliyuncs.com"]&#125; 重启docker服务，生效1# systemctl daemon-reload &amp;&amp; systemctl restart docker 拉取queens版本的kolla镜像123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150# cat 01_pull_kolla.sh #!/usr/bin/bashimage_tag=queens #该变量，你可以根据自己需要进行修改# delete imagesdocker images | awk '&#123;print $3&#125;' | xargs docker rmi -f# pull public imagesfor public_images in memcached kolla-toolbox cron mongodb mariadb rabbitmq keepalived haproxy chrony iscsid tgtddo docker pull kolla/centos-source-$public_images:$image_tagdone# pull monitor manage images# it is recommended to use telegraf + influxdb + grafana + collectd + Prometheusfor monitor_images in collectd telegraf grafana influxdb prometheus-server prometheus-haproxy-exporter prometheus-node-exporter prometheus-mysqld-exporterdo docker pull kolla/centos-source-$monitor_images:$image_tagdone# pull log manage imagesfor log_images in fluentd elasticsearch kibanado docker pull kolla/centos-source-$log_images:$image_tagdone# pull novafor nova in nova-compute nova-consoleauth nova-ssh nova-placement-api nova-api nova-compute-ironic nova-consoleauth nova-serialproxy nova-scheduler nova-novncproxy nova-conductor nova-libvirtdo docker pull kolla/centos-source-$nova:$image_tagdone# pull keystonedocker pull kolla/centos-source-keystone:$image_tag# pull freezerdocker pull kolla/centos-source-freezer-api:$image_tag# pull glance for glance in glance-api glance-registrydo docker pull kolla/centos-source-$glance:$image_tagdone# pull cinderfor cinder in cinder-volume cinder-api cinder-backup cinder-schedulerdo docker pull kolla/centos-source-$cinder:$image_tagdone# pull neutronfor neutron in neutron-server neutron-lbaas-agent neutron-dhcp-agent neutron-l3-agent neutron-openvswitch-agent neutron-metadata-agent neutron-server-opendaylight opendaylightdo docker pull kolla/centos-source-$neutron:$image_tagdone# pull openvswitchfor openvswitch in openvswitch-db-server openvswitch-vswitchd neutron-openvswitch-agentdo docker pull kolla/centos-source-$openvswitch:$image_tagdone# pull ceilometerfor ceilometer in ceilometer-api ceilometer-compute ceilometer-notification ceilometer-centraldo docker pull kolla/centos-source-$ceilometer:$image_tagdone# pull gnocchifor gnocchi in gnocchi-metricd gnocchi-api gnocchi-statsddo docker pull kolla/centos-source-$gnocchi:$image_tagdone# pull aodhfor aodh in aodh-evaluator aodh-api aodh-listener aodh-notifierdo docker pull kolla/centos-source-$aodh:$image_tagdone# pull heatfor heat in heat-api heat-api-cfn heat-enginedo docker pull kolla/centos-source-$heat:$image_tagdone# pull horizondocker pull kolla/centos-source-horizon:$image_tag# pull muranofor murano in murano-api murano-enginedo docker pull kolla/centos-source-$murano:$image_tagdone# pull magnumfor magnum in magnum-api magnum-conductordo docker pull kolla/centos-source-$magnum:$image_tagdone# pull senlinfor senlin in senlin-api senlin-enginedo docker pull kolla/centos-source-$senlin:$image_tagdone# pull saharafor sahara in sahara-engine sahara-apido docker pull kolla/centos-source-$sahara:$image_tagdone# pull trovefor trove in trove-api trove-taskmanager trove-conductordo docker pull kolla/centos-source-$trove:$image_tagdone# pull swiftfor swift in swift-rsyncd swift-proxy-server swift-object-expirer swift-object swift-account swift-container swift-basedo docker pull kolla/centos-source-$swift:$image_tagdone# pull ironicfor ironic in ironic-conductor ironic-pxe ironic-api ironic-inspectordo docker pull kolla/centos-source-$ironic:$image_tagdonedocker pull kolla/centos-source-dnsmasq:pikedocker tag kolla/centos-source-dnsmasq:pike kolla/centos-source-dnsmasq:queensdocker rmi -f kolla/centos-source-dnsmasq:pike# pull cloudkittyfor cloudkitty in cloudkitty-api cloudkitty-processor panko-apido docker pull kolla/centos-source-$cloudkitty:$image_tagdone# pull kuryrdocker pull kolla/centos-source-kuryr-libnetwork:$image_tag# save imagesimages=`docker images | grep queens | awk '&#123;print $1&#125;'`docker save -o kolla_queens_images.tar $images# clean pull's imagesdocker images | awk '&#123;print $3&#125;' | xargs docker rmi -f 将镜像push到本地Registry12345678910111213141516171819202122232425262728# cat 02_push_kolla.sh #!/usr/bin/bash# load imagesdocker load --input kolla_queens_images.tarregistry=172.17.51.27:4000 #请将该registry地址，改为你自己环境的地址# tag imagesimages=`docker images | grep queens | awk '&#123;print $1&#125;'`for images_tag in $imagesdo docker tag $images_tag:queens $registry/$images_tag:queensdone# delete old's imagesdelete_images=`docker images | grep '^kolla' | awk '&#123;print $1&#125;'`for delete_images1 in $delete_imagesdo docker rmi $delete_images1:queensdone# push imagespush_images=`docker images | grep queens | awk '&#123;print $1&#125;'`for push_images1 in $push_imagesdo docker push $push_images1:queensdone 综合，比较以上三种方法的优缺点。这里，推荐使用第一种或第三种方法，速度更快，也更便捷。]]></content>
      <categories>
        <category>OpenStack</category>
        <category>Kolla</category>
      </categories>
      <tags>
        <tag>Kolla</tag>
        <tag>OpenStack</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何设置OpenStack节点Swap分区]]></title>
    <url>%2F2018%2F05%2F07%2F%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEOpenStack%E8%8A%82%E7%82%B9Swap%E5%88%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[Swap分区介绍Swap分区，即交换分区。它的功能就是在物理内存不够的情况下，操作系统先把内存中暂时不用的数据，存到硬盘的交换空间，腾出内存来让别的程序运行，当程序需要用到交换空间内的数据的时候，操作系统再将数据从交换分区恢复到物理内存中。这样，系统总是在物理内存不够时，才进行Swap交换。 如何设置Swap分区大小以上是SWAP 交换分区的作用。 实际上，我们更关注的应该是SWAP分区的大小问题。 设置多大才是最优的。如下，提供了两种方案。 方案一在Linux系统中，我们可以参照Red Hat公司为RHEL 7推荐的SWAP空间的大小划分原则，在你没有其他特别需求时，可以作为很好的参考依据。 内存小于2GB，推荐2倍于内存的swap空间； 内存2GB~8GB，推荐和内存大小一样的swap空间； 内存8GB~64GB，推荐至少4GB的swap空间； 内存大于64GB，推荐至少4GB的swap空间。 原文链接 实际上，系统中交换分区的大小并不取决于物理内存的量，而是取决于系统中内存的负荷，所以在安装系统时要根据具体的业务来设置SWAP的值。 在OpenStack中，默认的CPU超配比例是1:16，内存超配比例是1:1.5。当宿主机使用swap交换分区来为虚拟机分配内存的时候，则虚拟机的性能将急速下降。生产环境上不建议开启内存超售（建议配置比例1:1）。另外，建议设置nova.conf文件中的reserved_host_memory_mb 参数，即内存预留量（建议至少预留4GB），保证该部分内存不能被虚拟机使用。 方案二系统在什么情况下才会使用Swap？实际上，并不是等所有的物理内存都消耗完毕之后，才去使用swap的空间，什么时候使用是由swappiness 参数值控制的。12# cat /proc/sys/vm/swappiness60 该值默认值是60。 swappiness=0的时候表示最大限度使用物理内存，然后才是 swap空间。 swappiness＝100的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面。 由于，现在服务器的内存一般是上百GB，所以我们可以把这个参数值设置的低一些（如10-30之间），让操作系统尽可能的使用物理内存，降低系统对swap的使用，从而提高宿主机系统和虚拟机的性能。 永久性修改1# echo 'vm.swappiness=10' &gt;&gt;/etc/sysctl.conf 保存，重启就生效了。 查看系统当前SWAP 空间大小1# free –h 小结 为了保证主机系统和应用程序的稳定运行（内存不足或泄露，易导致系统或应用崩溃），建议在实际使用过程中，服务器仍然需要创建一定的Swap分区。其分区大小可以结合以上两种方案进行设置，已达到最佳效果。 FAQ1.释放SWAP 空间 假设我们的系统出现了性能问题，我们通过vmstat命令看到有大量的swap，而我们的物理内存又很充足，那么我们可以手工把swap 空间释放出来。让进程去使用物理内存，从而提高性能。 我们对swap 空间的释放，可以通过关闭swap分区，再启动swap 分区来实现。123# vmstat 1 5 // 1表示每隔1秒采集一次服务器状态，5表示只采集5次# free -h# swapon -s //显示交换分区的使用状况 关闭swap 交换分区：12# swapoff /dev/sda2# swapon -s 启用swap分区：1# swapon /dev/sda2 验证状态：1# swapon -s Swap分区的拓展和缩小：https://www.e-learn.cn/content/linux/339010]]></content>
      <categories>
        <category>OpenStack</category>
      </categories>
      <tags>
        <tag>OpenStack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kolla中配置OpenStack虚机网络vxlan和vlan共存]]></title>
    <url>%2F2018%2F05%2F03%2FKolla%E4%B8%AD%E9%85%8D%E7%BD%AEOpenStack%E8%99%9A%E6%9C%BA%E7%BD%91%E7%BB%9Cvxlan%E5%92%8Cvlan%E5%85%B1%E5%AD%98%2F</url>
    <content type="text"><![CDATA[OpenStack Neutron网络服务定义了四种网络模式：1234# tenant_network_type = local# tenant_network_type = vlan # tenant_network_type = gre# tenant_network_type = vxlan 这里，本文以vlan、vxlan为例，阐述如何实现OpenStack虚机网络（亦称租户网络、业务网络）同时支持vxlan和vlan两种网络。 说明 环境：Openstack queens版本 部署工具：kolla-ansible 在kolla-ansible部署节点的/etc/kolla/globals.yml文件中，配置网卡。如下所示。 eth0：openstack管理网络；vlan 51，交换机端口设置为Access模式 eth1：虚机网络(vxlan)；vlan 52，交换机端口设置为Access模式 eth2：外部网络兼虚机网络(vlan)；vlan网段53-54，交换机端口设置为trunk模式，主机不配置IP地址 在所有网络节点上，操作如下修改文件/etc/kolla/neutron-server/ml2_conf.ini 修改文件/etc/kolla/neutron-openvswitch-agent/ml2_conf.ini 重启neutron容器1# docker restart neutron_server neutron_openvswitch_agent 在网络节点上，查看br-ex网桥设置情况，如下。 在所有计算节点上，操作如下修改文件/etc/kolla/neutron-openvswitch-agent/ml2_conf.ini 创建一个br-ex外部网桥，并关联到主机的eth2物理网卡上。这样，当计算节点上的虚拟机使用vlan网络时，便可以直接通过qbr-&gt;br-int-&gt;br-ex-&gt;eth2连接到外网。（vlan网络的三层路由，建议使用物理路由器，这样性能和稳定性更好，而不需要通过网络节点上的L3 vRouter虚拟路由）。12# docker exec -u root -it neutron_openvswitch_agent ovs-vsctl add-br br-ex# docker exec -u root -it neutron_openvswitch_agent ovs-vsctl add-port br-ex eth2 最后，重启相关容器1# docker restart neutron_openvswitch_agent 在计算节点上，查看br-ex网桥设置情况，如下。 创建一个vlan id为53的网段123# neutron net-create vlan-53 --shared --provider:physical_network physnet1 --provider:network_type vlan --provider:segmentation_id 53# neutron subnet-create vlan-53 172.17.53.0/24 --name provider-53-subnet --gateway 172.17.53.1 查看创建的网络，如下。12345678# neutron net-list+--------------------------------------+----------------+----------------------------------+-----------------------------------------------------+| id | name | tenant_id | subnets |+--------------------------------------+----------------+----------------------------------+-----------------------------------------------------+| 5d9c4874-e03b-4bde-aee0-947d7dde4860 | vlan-53 | 48fbadff0ab84229b429166babbe488f | 9bade37c-ff44-4004-8e82-20d61348fdc0 172.17.53.0/24 || 7b0152da-a975-4dbf-b35b-437951c66efa | tenant_network | 48fbadff0ab84229b429166babbe488f | a45516a4-4ce9-4c2e-8052-8c71eae0e219 10.0.0.0/24 || 9630cf8b-4072-415b-a9a9-99ff815748f8 | public_network | 48fbadff0ab84229b429166babbe488f | a98f8c80-78de-43ba-af52-d86c19fc59ef 172.17.54.0/24 |+--------------------------------------+----------------+----------------------------------+-----------------------------------------------------+ 最后，创建一个虚拟机并使用该vlan网络。1234# nova boot --flavor 1Gmem_1cpu --image centos7 --nic net-id=5d9c4874-e03b-4bde-aee0-947d7dde4860 test_vm# nova list | grep test_vm| f506129b-610f-4e2d-886b-5d791cdcb282 | test_vm | ACTIVE | - | Running | vlan-53=172.17.53.7 测试虚拟机网络通信123456# ping -c 4 172.17.53.7PING 172.17.53.7 (172.17.53.7) 56(84) bytes of data.64 bytes from 172.17.53.7: icmp_seq=1 ttl=63 time=0.421 ms64 bytes from 172.17.53.7: icmp_seq=2 ttl=63 time=0.503 ms64 bytes from 172.17.53.7: icmp_seq=3 ttl=63 time=0.543 ms64 bytes from 172.17.53.7: icmp_seq=4 ttl=63 time=0.469 ms br-int和br-ex说明 br-int br-int是OpenVswitch中的集成网桥，类似于一个二层的交换机。上面挂载了大量的agent来提供各种网络服务，另外负责对发往br-ex的流量，实现local vlan转化为外部vlan。12345# ovs-ofctl dump-flows br-int NXST_FLOW reply (xid=0x4): cookie=0x0, duration=147294.121s, table=0, n_packets=224, n_bytes=33961, idle_age=13, hard_age=65534, priority=3,in_port=4,dl_vlan=1 actions=mod_vlan_vid:101,NORMAL cookie=0x0, duration=603538.84s, table=0, n_packets=19, n_bytes=2234, idle_age=18963, hard_age=65534, priority=2,in_port=4 actions=drop cookie=0x0, duration=603547.134s, table=0, n_packets=31901, n_bytes=6419756, idle_age=13, hard_age=65534, priority=1 actions=NORMAL br-ex br-ex是OpenVswitch中的一个外部网桥，要做的事情很简单，只需要正常转发数据流量即可。123# ovs-ofctl dump-flows br-ex NXST_FLOW reply (xid=0x4): cookie=0x0, duration=6770.969s, table=0, n_packets=5411, n_bytes=306944, idle_age=0, hard_age=65534, priority=0 actions=NORMAL]]></content>
      <categories>
        <category>OpenStack</category>
      </categories>
      <tags>
        <tag>Kolla</tag>
        <tag>OpenStack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何删除Registry中kolla-ansible的镜像]]></title>
    <url>%2F2018%2F04%2F30%2F%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4Registry%E4%B8%ADkolla-ansible%E7%9A%84%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[出于某些情况，如释放磁盘空间、旧镜像删除等原因，需要我们删除本地Registry仓库中的镜像。本篇文章，将讲解如何在OpenStack环境的kolla-ansible中，删除本地Registry中的镜像。 Registry中的镜像管理查看Registry仓库中现有的镜像：1#curl -XGET http://172.17.51.51:4000/v2/_catalog 查看Registry仓库中指定的镜像，如这里的centos-source-magnum-conductor。1#curl -XGET http://172.17.51.51:4000/v2/kolla/centos-source-magnum-conductor/tags/list 如何删除私有 registry 中的镜像首先，在默认情况下，docker registry 是不允许删除镜像的，需要在配置文件config.yml中启用。123456789101112131415161718192021#vim /etc/docker/registry/config.ymlversion: 0.1log: fields: service: registrystorage: cache: blobdescriptor: inmemory filesystem: rootdirectory: /var/lib/registry delete: enabled: truehttp: addr: :5000 headers: X-Content-Type-Options: [nosniff]health: storagedriver: enabled: true interval: 10s threshold: 3 修改后，需要重启registry容器1#docker restart registry 使用API接口 GET /v2/&lt;镜像名&gt;/manifests/ 来取得要删除的镜像:Tag所对应的 digest。比如，要删除kolla/centos-source-magnum-conductor:queens镜像，那么取得 digest 的命令是：123456789#curl --header "Accept: application/vnd.docker.distribution.manifest.v2+json" -I -X HEAD http://172.17.51.51:4000/v2/kolla/centos-source-magnum-conductor/manifests/queensHTTP/1.1 200 OKContent-Length: 8666Content-Type: application/vnd.docker.distribution.manifest.v2+jsonDocker-Content-Digest: sha256:e94c4d08520a7f77cbfa0c2d314bc9281d07874b8c7d9337ad5f541832f7d868Docker-Distribution-Api-Version: registry/2.0Etag: "sha256:e94c4d08520a7f77cbfa0c2d314bc9281d07874b8c7d9337ad5f541832f7d868"X-Content-Type-Options: nosniffDate: Sat, 28 Apr 2018 02:44:46 GMT 得到 Docker-Content-Digest:1sha256:e94c4d08520a7f77cbfa0c2d314bc9281d07874b8c7d9337ad5f541832f7d868 然后调用API接口 DELETE /v2/&lt;镜像名&gt;/manifests/ 来删除镜像。比如：1234567#curl -I -X DELETE http://172.17.51.51:4000/v2/kolla/centos-source-magnum-conductor/manifests/sha256:e94c4d08520a7f77cbfa0c2d314bc9281d07874b8c7d9337ad5f541832f7d868HTTP/1.1 202 AcceptedDocker-Distribution-Api-Version: registry/2.0X-Content-Type-Options: nosniffDate: Sat, 28 Apr 2018 03:34:31 GMTContent-Length: 0Content-Type: text/plain; charset=utf-8 至此，镜像已从 registry 中标记删除，外界访问 pull 不到了。但是 registry 的本地空间并未释放，需要垃圾收集才会释放。1#docker exec registry bin/registry garbage-collect /etc/docker/registry/config.yml]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Kolla</tag>
        <tag>OpenStack</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
</search>
